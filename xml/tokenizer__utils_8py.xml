<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="tokenizer__utils_8py" kind="file" language="Python">
    <compoundname>tokenizer_utils.py</compoundname>
    <innernamespace refid="namespacebittensor">bittensor</innernamespace>
    <innernamespace refid="namespacebittensor_1_1utils">bittensor::utils</innernamespace>
    <innernamespace refid="namespacebittensor_1_1utils_1_1tokenizer__utils">bittensor::utils::tokenizer_utils</innernamespace>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1ace858cca96a45c6171798f08dfe507fb" prot="public" static="no" mutable="no">
        <type>int</type>
        <definition>int bittensor::utils::tokenizer_utils.EPSILON</definition>
        <argsstring></argsstring>
        <name>EPSILON</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.EPSILON</qualifiedname>
        <initializer>=  1e-40</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="25" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="25" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a31406026136d3c9b3ec5469bd1e0c0f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Dict[int, tuple]</type>
        <definition> Dict[int, tuple] bittensor.utils.tokenizer_utils.get_tokenizer_alignment_splits</definition>
        <argsstring>(List[tuple] offset_mapping, List[tuple] offset_mapping_std)</argsstring>
        <name>get_tokenizer_alignment_splits</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_tokenizer_alignment_splits</qualifiedname>
        <param>
          <type>List</type>
          <declname>offset_mapping</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping_std</declname>
          <array>[tuple]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    Calculates split depths necessary for tokens to align input offsets to standard offsets.
    Only input offsets may be split, not standard offsets, to create one-to-one, one-to-many, or many-to-one
    token alignments between input-to-standard tokenization.
    Allows for multiple depth splits on a token.
        Args:
            offset_mapping (:obj:`List[tuple]`, `required`):
                Tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...].
            offset_mapping_std (:obj:`List[tuple]`, `required`):
                Standard tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...]

        Returns:
            splits (:obj:`Dict[int, tuple]`, `required`):
                For tokens that have to be split, {Token index: (split depth 1, split depth 2, ...), ...}.</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="28" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="28" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a80673928d5022558ece6eb5cdc9e12be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>List[tuple]</type>
        <definition> List[tuple] bittensor.utils.tokenizer_utils.get_tokenizer_sequence_mappings</definition>
        <argsstring>(List[tuple] offset_mapping, List[tuple] offset_mapping_std)</argsstring>
        <name>get_tokenizer_sequence_mappings</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_tokenizer_sequence_mappings</qualifiedname>
        <param>
          <type>List</type>
          <declname>offset_mapping</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping_std</declname>
          <array>[tuple]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Greedily determine the one-to-one, one-to-many, or many-to-one token alignments
between input-to-standard tokenizations.
Disallow many-to-many mappings, but allow for right-aligned overlapping tokens.
Args:
offset_mapping (:obj:`List[tuple]`, `required`):
Tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...].
offset_mapping_std (:obj:`List[tuple]`, `required`):
Standard tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...]

Returns:
mappings (:obj:`List[tuple]`, `required`):
List of mapping tuples:
[tuple( right_idx, right_idx_std,
        segment_count_base, segment_count_std_base,
        segment_count_overlap, segment_count_std_overlap), ...]
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="141" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="141" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1af76d2962aae10ddc4826d5f349fd9051" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>List[Dict[str, torch.LongTensor]]</type>
        <definition> List[Dict[str, torch.LongTensor]] bittensor.utils.tokenizer_utils.get_tokenizer_depth_split_map</definition>
        <argsstring>(PreTrainedTokenizerBase tokenizer, tuple depths)</argsstring>
        <name>get_tokenizer_depth_split_map</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_tokenizer_depth_split_map</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>tuple</type>
          <declname>depths</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Split individual token strings at specified depths, retokenize each resulting segment,
keep only the first token of each segment (if there is one).
Purpose is to provide targets for scattering probabilities when a single distribution requires a depth split.
Args:
tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
Tokenizer.
depths (:obj:`tuple`, `required`):
Tuple of depths at which tokens strings will be split.

Returns:
split_map (:obj:`List[Dict[str, torch.LongTensor]]`, `required`):
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="254" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="255" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1af3a7513c8021247073b9f0f68d3e751a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch.FloatTensor</type>
        <definition> torch.FloatTensor bittensor.utils.tokenizer_utils.split_probs</definition>
        <argsstring>(torch.FloatTensor probs, List[Dict[str, torch.Tensor]] split_map)</argsstring>
        <name>split_probs</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.split_probs</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs</declname>
        </param>
        <param>
          <type>List]</type>
          <declname>split_map</declname>
          <array>[Dict[str, torch.Tensor]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Split a given probability distribution over a tokenizer vocabulary, given a split_map
of mappings from original tokens to target tokens at each depth of the split.
Args:
probs (:obj:`torch.FloatTensor`, `required`):
[vocab_size] Input probability distribution over a tokenizer vocabulary.
split_map (:obj:`List[Dict[str, torch.Tensor]]`, `required`):
A split_map of mappings from original tokens to target tokens at each depth of the split.

Returns:
new_probs (:obj:`torch.FloatTensor`, `required`):
[splits, vocab_size] A new tensor with resultant probability distribution at each index
of the first dim, representing corresponding split depth.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="293" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="293" bodyend="319"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8a5ed01b4d5f6883475c9db9f896edbe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Tuple[torch.FloatTensor, List[tuple], torch.LongTensor]</type>
        <definition> Tuple[torch.FloatTensor,
                                                                                               List[tuple],
                                                                                               torch.LongTensor] bittensor.utils.tokenizer_utils.align_tokenizer_sequences</definition>
        <argsstring>(torch.FloatTensor probs, List[tuple] offset_mapping, List[tuple] offset_mapping_std, PreTrainedTokenizerBase tokenizer, Dict[tuple, List[Dict[str, torch.Tensor]]] split_map_cache, torch.LongTensor tokens, torch.LongTensor tokens_std)</argsstring>
        <name>align_tokenizer_sequences</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.align_tokenizer_sequences</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs</declname>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping_std</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>Dict]]</type>
          <declname>split_map_cache</declname>
          <array>[tuple, List[Dict[str, torch.Tensor]</array>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens</declname>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens_std</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Align an input tokenization distribution to standard tokenization segments by depth-splitting
the input distribution at greedily chosen locations. Prepares the input distribution for mapping to a standard
distribution.
Args:
probs (:obj:`torch.FloatTensor`, `required`):
[sequence_len, vocab_size] Input probability distribution over a tokenizer vocabulary.
offset_mapping (:obj:`List[tuple]`, `required`):
Tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...].
offset_mapping_std (:obj:`List[tuple]`, `required`):
Standard tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...]
tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
Source tokenizer.
split_map_cache (:obj:`Dict[tuple, List[Dict[str, torch.Tensor]]]`, `required`):
A dictionary of depths keying split_maps of mappings from original tokens to
target tokens at each depth of the split.
tokens (:obj:`torch.LongTensor`, `required`):
[sequence_len] A sequence of tokens produced by the source tokenizer.
tokens_std (:obj:`torch.LongTensor`, `required`):
[std_sequence_len] A sequence of tokens produced by the standard tokenizer.

Returns:
aligned_probs (:obj:`torch.FloatTensor`, `required`):
[new_sequence_len, vocab_size] Aligned probability distribution over a tokenizer vocabulary.
aligned_offset_mapping (:obj:`List[tuple]`, `required`):
Tokenizer aligned offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...].
aligned_tokens (:obj:`torch.LongTensor`, `required`):
A sequence of aligned tokens produced by the source tokenizer.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="320" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="325" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a52d7949730e4e84f9a53fd0bff3e0f22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Dict[str, Any]</type>
        <definition> Dict[str, Any] bittensor.utils.tokenizer_utils.get_translation_map</definition>
        <argsstring>(PreTrainedTokenizerBase from_tokenizer, PreTrainedTokenizerBase to_tokenizer)</argsstring>
        <name>get_translation_map</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_translation_map</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>from_tokenizer</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>to_tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Map individual token phrases from a tokenizer to another tokenizer.
Args:
    from_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
        From tokenizer.
    to_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
        To tokenizer.

Returns:
    translation_map (:obj:`Dict[str, Any]`, `required`):
        Maps for each observed length, a source token to a token sequence of that length,
        with source index to target indices.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="405" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="406" bodyend="446"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a127face1324f46e879f92ee881771d90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None bittensor.utils.tokenizer_utils.translate_one_to_many</definition>
        <argsstring>(torch.FloatTensor probs_from, torch.FloatTensor probs_to, Dict[str, Any] translation_map)</argsstring>
        <name>translate_one_to_many</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.translate_one_to_many</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs_from</declname>
        </param>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs_to</declname>
        </param>
        <param>
          <type>Dict</type>
          <declname>translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Translate a single token probability distribution from a source tokenization to a
sequence of probability distributions over a target tokenization.
Args:
    probs_from (:obj:`torch.FloatTensor`, `required`):
        [vocab_size] Input probability distribution over a from-tokenizer vocabulary.
    probs_to (:obj:`torch.FloatTensor`, `required`):
        [many, vocab_size] Output probability distributions over a to-tokenizer vocabulary.
    translation_map (:obj:`Dict[str, Any]`, `required`):
        Maps for each observed length, a source token to a token sequence of that length,
        with source index to target indices.

Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="447" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="448" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1aacc9d76a7e49b18c20a5b44beafb8306" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None bittensor.utils.tokenizer_utils.translate_many_to_one</definition>
        <argsstring>(torch.FloatTensor probs_from, torch.FloatTensor probs_to, Dict[str, Any] translation_map)</argsstring>
        <name>translate_many_to_one</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.translate_many_to_one</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs_from</declname>
        </param>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs_to</declname>
        </param>
        <param>
          <type>Dict</type>
          <declname>translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>    Translate a sequence of token probability distributions from a source tokenization to a
    single token probability distribution over a target tokenization.
        Args:
            probs_from (:obj:`torch.FloatTensor`, `required`):
                [many, vocab_size] Input probability distributions over a from-tokenizer vocabulary.
            probs_to (:obj:`torch.FloatTensor`, `required`):
                [vocab_size] Output probability distribution over a to-tokenizer vocabulary.
            translation_map (:obj:`Dict[str, Any]`, `required`):
                Maps for each observed length, a source token to a token sequence of that length,
                with source index to target indices.

        Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="476" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="477" bodyend="514"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1ac2ac0a649cfc204c56ad13913288a4f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>None</type>
        <definition> None bittensor.utils.tokenizer_utils.translate_tokenizer_probs</definition>
        <argsstring>(torch.FloatTensor probs, torch.FloatTensor probs_std, List[tuple] offset_mapping, List[tuple] offset_mapping_std, PreTrainedTokenizerBase tokenizer, PreTrainedTokenizerBase std_tokenizer, Dict[tuple, List[Dict[str, torch.Tensor]]] split_map_cache, Dict[str, Any] to_translation_map, Dict[str, Any] from_translation_map, torch.LongTensor tokens, torch.LongTensor tokens_std)</argsstring>
        <name>translate_tokenizer_probs</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.translate_tokenizer_probs</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs</declname>
        </param>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs_std</declname>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>List</type>
          <declname>offset_mapping_std</declname>
          <array>[tuple]</array>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>std_tokenizer</declname>
        </param>
        <param>
          <type>Dict]]</type>
          <declname>split_map_cache</declname>
          <array>[tuple, List[Dict[str, torch.Tensor]</array>
        </param>
        <param>
          <type>Dict</type>
          <declname>to_translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <param>
          <type>Dict</type>
          <declname>from_translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens</declname>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens_std</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Translates source token probability distributions to target probability distributions, by
aligning segments through source token splits, then greedily performing one-to-one,
one-to-many, many-to-one distribution mappings.
    Args:
        probs (:obj:`torch.FloatTensor`, `required`):
            [sequence_len, vocab_size] Input probability distribution over a source tokenizer vocabulary.
        probs_std (:obj:`torch.FloatTensor`, `required`):
            [std_sequence_len, std_vocab_size] Output probability distribution over a target tokenizer vocabulary.
            Reference that will be written in-place.
        offset_mapping (:obj:`List[tuple]`, `required`):
            Tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...].
        offset_mapping_std (:obj:`List[tuple]`, `required`):
            Standard tokenizer offset mappings for a specific sequence [(left_0, right_0), (left_1, right_1), ...]
        tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Source tokenizer.
        std_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Standard/target tokenizer.
        split_map_cache (:obj:`Dict[tuple, List[Dict[str, torch.Tensor]]]`, `required`):
            A dictionary of depths keying split_maps of mappings from original tokens to
            target tokens at each depth of the split. Adds split_maps to cache for faster future recall.
        tokens (:obj:`torch.LongTensor`, `required`):
            [sequence_len] A sequence of tokens produced by the source tokenizer.
        tokens_std (:obj:`torch.LongTensor`, `required`):
            [std_sequence_len] A sequence of tokens produced by the standard tokenizer.
        to_translation_map (:obj:`Dict[str, Any]`, `required`):
            Maps for each observed length, a source token to a token sequence of that length,
            with source index to target indices.
        from_translation_map (:obj:`Dict[str, Any]`, `required`):
            Maps for each observed length, a source token to a token sequence of that length,
            from target index to source indices.

    Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="515" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="520" bodyend="590"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1aa9eb42e9db4c2b1517d8ff7105c8ebd2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>str</type>
        <definition> str bittensor.utils.tokenizer_utils.get_top_probs</definition>
        <argsstring>(torch.FloatTensor probs, PreTrainedTokenizerBase tokenizer, int amount=10)</argsstring>
        <name>get_top_probs</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_top_probs</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>probs</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>amount</declname>
          <defval>10</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Constructs output string with top amount of highest probability token strings.
Used to display the top probabilities.
Args:
    probs (:obj:`torch.FloatTensor`, `required`):
        [vocab_size] Probability distribution over a tokenizer vocabulary.
    tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
        Tokenizer.
    amount: (:obj:`int`, `optional`):
        Amount of top tokens to return

Returns:
    string (:obj:`str`, `required`):
    Highest probability token strings, prob[token-string] ...
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="591" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="591" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a7c296be466fd118c374bf1480d26904b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch.FloatTensor</type>
        <definition> torch.FloatTensor bittensor.utils.tokenizer_utils.translate_logits_to_probs_std</definition>
        <argsstring>(torch.FloatTensor logits, List[List[tuple]] offset_mapping, List[List[tuple]] offset_mapping_std, PreTrainedTokenizerBase tokenizer, PreTrainedTokenizerBase std_tokenizer, Dict[tuple, List[Dict[str, torch.Tensor]]] split_map_cache, Dict[str, Any] to_translation_map, Dict[str, Any] from_translation_map, torch.LongTensor tokens, torch.LongTensor tokens_std, bool skip_equivalent=True)</argsstring>
        <name>translate_logits_to_probs_std</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.translate_logits_to_probs_std</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>logits</declname>
        </param>
        <param>
          <type>List]</type>
          <declname>offset_mapping</declname>
          <array>[List[tuple]</array>
        </param>
        <param>
          <type>List]</type>
          <declname>offset_mapping_std</declname>
          <array>[List[tuple]</array>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>std_tokenizer</declname>
        </param>
        <param>
          <type>Dict]]</type>
          <declname>split_map_cache</declname>
          <array>[tuple, List[Dict[str, torch.Tensor]</array>
        </param>
        <param>
          <type>Dict</type>
          <declname>to_translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <param>
          <type>Dict</type>
          <declname>from_translation_map</declname>
          <array>[str, Any]</array>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens</declname>
        </param>
        <param>
          <type>torch.LongTensor</type>
          <declname>tokens_std</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>skip_equivalent</declname>
          <defval>True</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Translates source token logit scores to probability distributions over the standard tokenizer.
    Args:
        logits (:obj:`torch.FloatTensor`, `required`):
            [batch_size, sequence_len, vocab_size] Input source logits over a source tokenizer vocabulary.
        offset_mapping (:obj:`List[List[tuple]]`, `required`):
            Batch of tokenizer offset mappings
            [[(left_0, right_0), (left_1, right_1), ...], ...].
        offset_mapping_std (:obj:`List[List[tuple]]`, `required`):
            Batch of standard tokenizer offset mappings
            [[(left_0, right_0), (left_1, right_1), ...], ...].
        tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Source tokenizer.
        std_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Standard/target tokenizer.
        split_map_cache (:obj:`Dict[tuple, List[Dict[str, torch.Tensor]]]`, `required`):
            A dictionary of depths keying split_maps of mappings from original tokens to
            target tokens at each depth of the split. Adds split_maps to cache for faster future recall.
        tokens (:obj:`torch.LongTensor`, `required`):
            [batch_size, sequence_len] A sequence of tokens produced by the source tokenizer.
        tokens_std (:obj:`torch.LongTensor`, `required`):
            [batch_size, std_sequence_len] A sequence of tokens produced by the standard tokenizer.
        to_translation_map (:obj:`Dict[str, Any]`, `required`):
            Maps for each observed length, a source token to a token sequence of that length,
            with source index to target indices.
        from_translation_map (:obj:`Dict[str, Any]`, `required`):
            Maps for each observed length, a source token to a token sequence of that length,
            from target index to source indices.
        skip_equivalent (:obj:`bool`, `optional`):
            Skips translation if tokenizer and std_tokenizer are equivalent.

    Returns:
        probs_std (:obj:`torch.FloatTensor`, `required`):
            [batch_size, std_sequence_len, std_vocab_size] Output probability distribution over the
            standard tokenizer vocabulary.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="617" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="623" bodyend="709"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a619c2a8870fee58a3993722ad5e2d7bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch.Tensor</type>
        <definition> torch.Tensor bittensor.utils.tokenizer_utils.topk_token_phrases</definition>
        <argsstring>(torch.Tensor logits, PreTrainedTokenizerBase tokenizer, int topk, int ignore_index=-100)</argsstring>
        <name>topk_token_phrases</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.topk_token_phrases</qualifiedname>
        <param>
          <type>torch.Tensor</type>
          <declname>logits</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>topk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ignore_index</declname>
          <defval>-100</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Select topk tokenizer logits/phrases and include std_token_phrases counterparts (std_tokenization of token text)
in topk_tensor output of shape [batch_size, (topk + 1), max_len], where max len of all phrase lists
(with prob in front) is max_{b,k}(len([prob_k, tok_0_k, tok_1_k, ...])).
The output topk_tensor also includes a floor_prob for each batch item. The floor probability is the
mean probability of token phrases not captured in topk, required since the tokenizer vocab_size may
not be known to the receiver.
Requires prep_tokenizer(tokenizer, std_tokenizer) to set_std_token_phrases first, to make
std_token_phrases available here.
    Args:
        logits (:obj:`torch.Tensor`, `required`):
            [batch_size, vocab_size] Input source logits for last token over a source tokenizer vocabulary.
        tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Source tokenizer (usually server tokenizer)
        topk (:obj:`int`, `required`):
            Amount of top phrases to expect (to check for mismatch)
        ignore_index (:obj:`int`, `optional`):
            Padding value to use for unfilled token positions in a shorter token phrase.

    Returns:
        topk_tensor (:obj:`torch.Tensor`, `required`):
            [batch_size, (topk + 1), max_len] tensor includes topk token probabilities (prob_k) + floor_prob
            in first column with gradients attached, with std_tokens in remaining columns with ignore_index padding.
            Content structure:
            [[[prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., ignore_index?],
              [prob_k=1_b=0, tok_0_k=1_b=0, tok_1_k=1_b=0, ..., ignore_index?],
              [...],
              [prob_floor_b=0, ignore_index, ..., ignore_index]],
             [[prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., ignore_index?],
              [prob_k=1_b=1, tok_0_k=1_b=1, tok_1_k=1_b=1, ..., ignore_index?],
              [...],
              [prob_floor_b=1, ignore_index, ..., ignore_index]],
             [...]]
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="710" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="711" bodyend="795"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a335c0010cfa5615482ecc882408a8e0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.compact_topk_token_phrases</definition>
        <argsstring>(torch.Tensor topk_tensor)</argsstring>
        <name>compact_topk_token_phrases</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.compact_topk_token_phrases</qualifiedname>
        <param>
          <type>torch.Tensor</type>
          <declname>topk_tensor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Compact 2D topk_tensor [batch_size, (topk + 1), max_len] by removing ignore_index padding, and also offset
tokens by 2 to preserve [0, 1] for probabilities to allow for proper unraveling demarcated by
probability boundaries.
    Args:
        topk_tensor (:obj:`torch.Tensor`, `required`):
            [batch_size, (topk + 1), max_len] tensor includes topk token probabilities (prob_k) + floor_prob
            in first column with gradients attached, with std_tokens in remaining columns with ignore_index padding.
            Content structure:
            [[[prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., ignore_index?],
              [prob_k=1_b=0, tok_0_k=1_b=0, tok_1_k=1_b=0, ..., ignore_index?],
              [...],
              [prob_floor_b=0, ignore_index, ..., ignore_index]],
             [[prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., ignore_index?],
              [prob_k=1_b=1, tok_0_k=1_b=1, tok_1_k=1_b=1, ..., ignore_index?],
              [...],
              [prob_floor_b=1, ignore_index, ..., ignore_index]],
             [...]]

    Returns:
        compact_topk (:obj:`torch.Tensor`, `required`):
            [sum_b(sum_k(len(phrase_k) + 1)_b)] Compacted 1-D tensor &gt;= batch_size * (2 * topk + 1),
            since 2 * topk + 1: topk x [probability, token sequence (at least one token)] +
            floor probability (rest).
            Content structure:
                [prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., prob_k=1_b=0, tok_0_k=1_b=0, ..., prob_floor_b=0,
                 prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., prob_k=1_b=1, tok_0_k=1_b=1, ..., prob_floor_b=1,
                 ...]
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="796" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="796" bodyend="834"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a952b31d97e6588cd4166ee2ef319a1f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch.Tensor</type>
        <definition> torch.Tensor bittensor.utils.tokenizer_utils.unravel_topk_token_phrases</definition>
        <argsstring>(torch.Tensor compact_topk, int topk, int ignore_index=-100)</argsstring>
        <name>unravel_topk_token_phrases</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.unravel_topk_token_phrases</qualifiedname>
        <param>
          <type>torch.Tensor</type>
          <declname>compact_topk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>topk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ignore_index</declname>
          <defval>-100</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Unravel topk token phrases input_tensor from 1-D to [batch_size, (topk + 1), max_len] topk_tensor, which
includes topk token probabilities (prob_k) + floor_prob in first column with gradients attached, with
std_tokens in remaining columns with ignore_index padding.
    Args:
        compact_topk (:obj:`torch.Tensor`, `required`):
            [sum_b(sum_k(len(phrase_k) + 1)_b)] Compacted 1-D tensor &gt;= batch_size * (2 * topk + 1),
            since 2 * topk + 1: topk x [probability, token sequence (at least one token)] +
            floor probability (rest).
            Content structure:
                [prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., prob_k=1_b=0, tok_0_k=1_b=0, ..., prob_floor_b=0,
                 prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., prob_k=1_b=1, tok_0_k=1_b=1, ..., prob_floor_b=1,
                 ...]
        topk (:obj:`int`, `required`):
            Amount of top phrases to expect (to check for mismatch)
        ignore_index (:obj:`int`, `optional`):
            Padding value to use for unfilled token positions in a shorter token phrase.
    Returns:
        topk_tensor (:obj:`torch.Tensor`, `required`):
            [batch_size, (topk + 1), max_len] tensor includes topk token probabilities (prob_k) + floor_prob
            in first column with gradients attached, with std_tokens in remaining columns with ignore_index padding.
            Content structure:
            [[[prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., ignore_index?],
              [prob_k=1_b=0, tok_0_k=1_b=0, tok_1_k=1_b=0, ..., ignore_index?],
              [...],
              [prob_floor_b=0, ignore_index, ..., ignore_index]],
             [[prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., ignore_index?],
              [prob_k=1_b=1, tok_0_k=1_b=1, tok_1_k=1_b=1, ..., ignore_index?],
              [...],
              [prob_floor_b=1, ignore_index, ..., ignore_index]],
             [...]]
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="835" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="835" bodyend="915"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1ab00bac4739db21de5c408746fb2d631e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Tuple[torch.Tensor, torch.Tensor]</type>
        <definition> Tuple[torch.Tensor, torch.Tensor] bittensor.utils.tokenizer_utils.phrase_cross_entropy</definition>
        <argsstring>(Union[List[List[int]], torch.Tensor] target_phrases, torch.Tensor topk_tensor, int ignore_index=-100, reduce=True, reduction=&apos;mean&apos;, int vocab_size_min=50257)</argsstring>
        <name>phrase_cross_entropy</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.phrase_cross_entropy</qualifiedname>
        <param>
          <type>Union]</type>
          <defname>target_phrases</defname>
          <array>[List[List[int]</array>
        </param>
        <param>
          <type>torch.Tensor]</type>
          <declname>target_phrases</declname>
          <defname>topk_tensor</defname>
        </param>
        <param>
          <type>torch.Tensor</type>
          <declname>topk_tensor</declname>
          <defname>ignore_index</defname>
        </param>
        <param>
          <type>int</type>
          <declname>ignore_index</declname>
          <defname>reduce</defname>
          <defval>-100</defval>
        </param>
        <param>
          <type>reduce</type>
          <defname>reduction</defname>
          <defval>True</defval>
        </param>
        <param>
          <type>reduction</type>
          <defname>vocab_size_min</defname>
          <defval>&apos;mean&apos;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>vocab_size_min</declname>
          <defval>50257</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Calculates the cross entropy of a phrase prediction against a target phrase, so that this is a multi-token
extension of typical cross entropy calculated for next token prediction.
    Args:
        target_phrases (:obj:`List[List[int]]`, `required`):
            [batch_size, *] Target phrases in standard token sequence list.
        topk_tensor (:obj:`torch.Tensor`, `required`):
            [batch_size, (topk + 1), max_len] tensor includes topk token probabilities (prob_k) + floor_prob
            in first column with gradients attached, with std_tokens in remaining columns with ignore_index padding.
            Content structure:
            [[[prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., ignore_index?],
              [prob_k=1_b=0, tok_0_k=1_b=0, tok_1_k=1_b=0, ..., ignore_index?],
              [...],
              [prob_floor_b=0, ignore_index, ..., ignore_index]],
             [[prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., ignore_index?],
              [prob_k=1_b=1, tok_0_k=1_b=1, tok_1_k=1_b=1, ..., ignore_index?],
              [...],
              [prob_floor_b=1, ignore_index, ..., ignore_index]],
             [...]]
        ignore_index (:obj:`int`, `optional`):
            Padding value to use for unfilled token positions in a shorter token phrase.
        reduce (:obj:`bool`, `optional`):
            Whether to reduce the cross entropy over the batch dimension.
        reduction (:obj:`str`, `optional`):
            Reduction function to perform when reduce is True.
        vocab_size_min (:obj:`int`, `optional`):
            Minimum server vocab_size expected, should set to nominal 50257,
            used to prevent the floor_probs from being too large.
    Returns:
        loss_val (:obj:`torch.Tensor`, `required`):
            Validation cross entropy loss, either scalar if reduce or [batch_size].
        loss (:obj:`torch.Tensor`, `required`):
            Phrase cross entropy loss, either scalar if reduce or [batch_size].
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="916" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="919" bodyend="1016"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a66ebcf1b07d1ee0f0ba07130967a40cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>torch.Tensor</type>
        <definition> torch.Tensor bittensor.utils.tokenizer_utils.topk_tokens_to_vocab_size</definition>
        <argsstring>(torch.Tensor topk_tensor, int vocab_size_std, int vocab_size_min=50257)</argsstring>
        <name>topk_tokens_to_vocab_size</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.topk_tokens_to_vocab_size</qualifiedname>
        <param>
          <type>torch.Tensor</type>
          <declname>topk_tensor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>vocab_size_std</declname>
        </param>
        <param>
          <type>int</type>
          <declname>vocab_size_min</declname>
          <defval>50257</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Convert topk_tokens first token probabilities into a standard logits tensor shape [batch_size, vocab_size_std].
Args:
topk_tensor (:obj:`torch.Tensor`, `required`):
    [batch_size, (topk + 1), max_len] tensor includes topk token probabilities (prob_k) + floor_prob
    in first column with gradients attached, with std_tokens in remaining columns with ignore_index padding.
    Content structure:
    [[[prob_k=0_b=0, tok_0_k=0_b=0, tok_1_k=0_b=0, ..., ignore_index?],
      [prob_k=1_b=0, tok_0_k=1_b=0, tok_1_k=1_b=0, ..., ignore_index?],
      [...],
      [prob_floor_b=0, ignore_index, ..., ignore_index]],
     [[prob_k=0_b=1, tok_0_k=0_b=1, tok_1_k=0_b=1, ..., ignore_index?],
      [prob_k=1_b=1, tok_0_k=1_b=1, tok_1_k=1_b=1, ..., ignore_index?],
      [...],
      [prob_floor_b=1, ignore_index, ..., ignore_index]],
     [...]]
vocab_size_std (:obj:`int`, `optional`):
    Standard tokenizer vocab_size for forming logits.
vocab_size_min (:obj:`int`, `optional`):
    Minimum server vocab_size expected, should set to nominal 50257,
    used to prevent the floor_probs from being too large.
Returns:
logits (:obj:`torch.Tensor`, `required`):
    [batch_size, vocab_size_std] Standard logits.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1017" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1017" bodyend="1064"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a54a25644b9cfa6b662c66e0707692a72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition> bool bittensor.utils.tokenizer_utils.check_tokenizer_equivalence</definition>
        <argsstring>(PreTrainedTokenizerBase tokenizer_to_check, PreTrainedTokenizerBase target_tokenizer)</argsstring>
        <name>check_tokenizer_equivalence</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.check_tokenizer_equivalence</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer_to_check</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>target_tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Is tokenizer_to_check equivalent to target_tokenizer?
    Args:
        tokenizer_to_check (:obj:`PreTrainedTokenizerBase`, `required`):
            Tokenizer to check for equivalence.
        target_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Target tokenizer to check equivalence against.

    Returns:
        result (:obj:`bool`, `required`)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1065" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1066" bodyend="1089"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1abcdd922e5075b5eb136e9f056aa547c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.prune_tokens</definition>
        <argsstring>(torch.FloatTensor inputs, int prune_len=1, int margin=3)</argsstring>
        <name>prune_tokens</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.prune_tokens</qualifiedname>
        <param>
          <type>torch.FloatTensor</type>
          <declname>inputs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>prune_len</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>int</type>
          <declname>margin</declname>
          <defval>3</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Prune tokens from a batch of sequences randomly by removing prune_len tokens from each sequence,
leaving the end margin intact.
    Args:
        inputs (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, seq_len)`, `required`):
            Tensor inputs to have tokens pruned.
        prune_len (:obj:`int`, `optional`):
            Number of tokens to prune from each validation input sequence.
        margin (:obj:`int`, `optional`):
            Number of tokens at the end of the sequence to leave unpruned.
    Returns:
        pruned_inputs (:obj:`torch.FloatTensor` of shape :obj:`(batch_size, seq_len - prune_len)`, `required`)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1090" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1090" bodyend="1118"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a48b79b3d00a8fa64ade7ce9ba3db7410" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>List[List[List[Any]]]</type>
        <definition> List[List[List[Any]]] bittensor.utils.tokenizer_utils.pad_offsets</definition>
        <argsstring>(List[List[tuple]] offsets_batch, List[List[List[Any]]] source_offsets_batch, List[List[List[Any]]] pad_offsets_batch)</argsstring>
        <name>pad_offsets</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.pad_offsets</qualifiedname>
        <param>
          <type>List]</type>
          <declname>offsets_batch</declname>
          <array>[List[tuple]</array>
        </param>
        <param>
          <type>List]]</type>
          <declname>source_offsets_batch</declname>
          <array>[List[List[Any]</array>
        </param>
        <param>
          <type>List]]</type>
          <declname>pad_offsets_batch</declname>
          <array>[List[List[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Pads specific tuples in offsets_batch, selected by source_offsets_batch with
associated paddings in pad_offsets_batch.
Purpose is typically to add padding to align two tokenization offsets at special tokens.
    Args:
        offsets_batch (:obj:`List[List[tuple]]`, `required`):
                Batch of full input tokenizer offset mappings to be used for alteration
                [[(left_0, right_0), (left_1, right_1), ...], ...].
        source_offsets_batch (:obj:`List[List[List[Any]]]`, `required`):
                Batch of tokenizer offset mappings indicating replacement tuples in offsets_batch
                [[(left_0, right_0), (left_1, right_1), ...], ...].
        pad_offsets_batch (:obj:`List[List[List[Any]]]`, `required`):
                Batch of offset paddings associated with each source_offsets_batch replacement tuple
                [[(left_pad_0, right_pad_0), (left_pad_1, right_pad_1), ...], ...].

    Returns:
        new_offsets_batch (:obj:`List[List[List[Any]]]`, `required`):
                Batch of padded full input tokenizer offset mappings
                [[(left_0, right_0), (left_1, right_1), ...], ...].
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1119" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1120" bodyend="1164"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a58bc4ccb79ae645c72c7a5e4244b99d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>List[List[int]]</type>
        <definition> List[List[int]] bittensor.utils.tokenizer_utils.find_offsets</definition>
        <argsstring>(str string, str substring)</argsstring>
        <name>find_offsets</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.find_offsets</qualifiedname>
        <param>
          <type>str</type>
          <declname>string</declname>
        </param>
        <param>
          <type>str</type>
          <declname>substring</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Finds all the [start, end] offsets of substring in string.
Assumes there is no overlap of substring, nor recursive overlap.
    Args:
        string (:obj:`str`, `required`):
            Main string to find offsets in.
        substring (:obj:`str`, `required`):
            Substring to search for in string.

    Returns:
        offsets (:obj:`List[List[int]]`, `required`):
            Offsets denoting the [start, end] positions of substring in string.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1165" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1165" bodyend="1187"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8e57c9718294c345d7f4ff730970723d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Tuple[str, List[List[int]]]</type>
        <definition> Tuple[str, List[List[int]]] bittensor.utils.tokenizer_utils.replace_at_offsets</definition>
        <argsstring>(str string, List[List[Any]] offsets)</argsstring>
        <name>replace_at_offsets</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.replace_at_offsets</qualifiedname>
        <param>
          <type>str</type>
          <declname>string</declname>
        </param>
        <param>
          <type>List]</type>
          <declname>offsets</declname>
          <array>[List[Any]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Replace indicated [left, right] offset positions with a new substring, by
deleting [left, right] content and adding [left, left+len(substring)] substring,
adjusting offsets incrementally.
Assumes an incremental ordered, non-overlapping list of offsets, constructing
the new string incrementally and recording new offsets.
    Args:
        string (:obj:`str`, `required`):
            Main string to perform replacements for.
        offsets (:obj:`List[List[Any]]`, `required`):
            Offsets where replacements are made with replacement substring
            [[left_0, right_0, substring_0], ...]

    Returns:
        new_string (:obj:`str`, `required`):
            New string where replacements were made.
        new_offsets (:obj:`List[List[Any]]`, `required`):
            New offsets where replacements are now located
            [[left_0, right_0], [left_1, right_1], ...]
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1188" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1188" bodyend="1228"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a4da460aad949bf91a0f414c1a0f30df1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Dict[str, str]</type>
        <definition> Dict[str, str] bittensor.utils.tokenizer_utils.get_special_token_pairings</definition>
        <argsstring>(PreTrainedTokenizerBase from_tokenizer, PreTrainedTokenizerBase to_tokenizer)</argsstring>
        <name>get_special_token_pairings</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.get_special_token_pairings</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>from_tokenizer</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>to_tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Determines a prioritized matching of special token texts between two tokenizers.
Purpose is to produce replacement pairs so special token test is correctly represented for target tokenizer.
    Args:
        from_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            From tokenizer.
        to_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            To tokenizer.

    Returns:
        pairings (:obj:`Dict[str, str]`, `required`):
            Prioritized dictionary of From_special_token_text -&gt; To_special_token_text.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1229" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1230" bodyend="1258"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a6717d83c925189f86590b5ab3d88df17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Tuple[List[str], List[List[List[int]]], List[List[List[int]]], List[List[List[Any]]]]</type>
        <definition> Tuple[List[str],
                                                                                 List[List[List[int]]],
                                                                                 List[List[List[int]]],
                                                                                 List[List[List[Any]]]] bittensor.utils.tokenizer_utils.translate_special_token_text</definition>
        <argsstring>(List[str] text_batch, PreTrainedTokenizerBase from_tokenizer, PreTrainedTokenizerBase to_tokenizer)</argsstring>
        <name>translate_special_token_text</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.translate_special_token_text</qualifiedname>
        <param>
          <type>List</type>
          <declname>text_batch</declname>
          <array>[str]</array>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>from_tokenizer</declname>
        </param>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>to_tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Translates special_token signifier text in from_tokenizer to to_tokenizer special_token text, for
a given text_batch. Resulting to_text_batch can then be to_tokenized where special_tokens should
map to its single corresponding token, despite signifier text difference compared to from_tokenizer.
    Args:
        text_batch (:obj:`List[str]`, `required`):
            List of strings to translate special tokens for.
        from_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            From tokenizer.
        to_tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            To tokenizer.

    Returns:
        to_text_batch (:obj:`List[str]`, `required`):
            List of strings where special text has been replaced.
        from_offsets_batch (:obj:`List[List[List[int]]]`, `required`):
            Batch of tokenizer offset mappings selecting replacement tuples in from_tokenizer text
                [[(left_0, right_0), (left_1, right_1), ...], ...].
        to_offsets_batch (:obj:`List[List[List[int]]]`, `required`):
            Batch of tokenizer offset mappings selecting replacement tuples in to_tokenizer text
                [[(left_0, right_0), (left_1, right_1), ...], ...].
        pad_offsets_batch (:obj:`List[List[List[Any]]]`, `required`):
            Batch of offset paddings associated with each replacement tuple
                [[(left_pad_0, right_pad_0), (left_pad_1, right_pad_1), ...], ...].
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1259" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1263" bodyend="1318"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.set_vocab_len</definition>
        <argsstring>(PreTrainedTokenizerBase tokenizer)</argsstring>
        <name>set_vocab_len</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.set_vocab_len</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Sets the tokenizer.vocab_len if unset, to store the real vocabulary size according to the vocab or encoder.
    Args:
        tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Tokenizer to set vocab_len for.
    Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1319" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1319" bodyend="1336"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a558123e572c10af14c002993c9b04f36" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.set_whitespace_preserving</definition>
        <argsstring>(PreTrainedTokenizerBase tokenizer)</argsstring>
        <name>set_whitespace_preserving</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.set_whitespace_preserving</qualifiedname>
        <param>
          <type>PreTrainedTokenizerBase</type>
          <declname>tokenizer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Sets the tokenizer.whitespace_preserving if unset, indicates if tokenizer preserves whitespace like GPT-style,
or not like BERT-style.
    Args:
        tokenizer (:obj:`PreTrainedTokenizerBase`, `required`):
            Tokenizer to set vocab_len for.
    Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1337" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1337" bodyend="1355"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1a066a0913f46f47503972e5df32808063" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.set_std_token_phrases</definition>
        <argsstring>(tokenizer, std_tokenizer)</argsstring>
        <name>set_std_token_phrases</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.set_std_token_phrases</qualifiedname>
        <param>
          <type>tokenizer</type>
          <defname>tokenizer</defname>
        </param>
        <param>
          <type>std_tokenizer</type>
          <defname>std_tokenizer</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Sets std_token_phrases which are the tokenizer token strings tokenized with std_tokenizer, so
the std_tokenizer equivalent of the tokenizer token strings.
Used for converting model predictions/logits into std_tokenizer representations, for example in TextCausalLMNext.
    Args:
        tokenizer(:obj:`PreTrainedTokenizerBase`, `required`):
            Tokenizer to set std_token_phrases for.
        std_tokenizer(:obj:`PreTrainedTokenizerBase`, `required`):
            Standard bittensor tokenizer to convert to.

    Returns:</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1356" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1356" bodyend="1382"/>
      </memberdef>
      <memberdef kind="function" id="namespacebittensor_1_1utils_1_1tokenizer__utils_1af7fd6b7e6dee158a3f991bdd93a1f559" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def bittensor.utils.tokenizer_utils.prep_tokenizer</definition>
        <argsstring>(tokenizer, std_tokenizer=None)</argsstring>
        <name>prep_tokenizer</name>
        <qualifiedname>bittensor.utils.tokenizer_utils.prep_tokenizer</qualifiedname>
        <param>
          <type>tokenizer</type>
          <defname>tokenizer</defname>
        </param>
        <param>
          <type>std_tokenizer</type>
          <defname>std_tokenizer</defname>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" line="1383" column="1" bodyfile="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py" bodystart="1383" bodyend="1424"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1" refid="namespacebittensor_1_1utils_1_1tokenizer__utils" refkind="compound"><highlight class="stringliteral">&quot;&quot;&quot;<sp/>Utils<sp/>for<sp/>tokenizer<sp/>equivalence<sp/>checking,<sp/>logit<sp/>translation,<sp/>etc.</highlight></codeline>
<codeline lineno="2"><highlight class="stringliteral">&quot;&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">#<sp/>The<sp/>MIT<sp/>License<sp/>(MIT)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">#<sp/>Copyright<sp/><sp/>2021<sp/>Yuma<sp/>Rao</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">#<sp/>Permission<sp/>is<sp/>hereby<sp/>granted,<sp/>free<sp/>of<sp/>charge,<sp/>to<sp/>any<sp/>person<sp/>obtaining<sp/>a<sp/>copy<sp/>of<sp/>this<sp/>software<sp/>and<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">#<sp/>documentation<sp/>files<sp/>(the<sp/>Software),<sp/>to<sp/>deal<sp/>in<sp/>the<sp/>Software<sp/>without<sp/>restriction,<sp/>including<sp/>without<sp/>limitation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">#<sp/>the<sp/>rights<sp/>to<sp/>use,<sp/>copy,<sp/>modify,<sp/>merge,<sp/>publish,<sp/>distribute,<sp/>sublicense,<sp/>and/or<sp/>sell<sp/>copies<sp/>of<sp/>the<sp/>Software,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="comment">#<sp/>and<sp/>to<sp/>permit<sp/>persons<sp/>to<sp/>whom<sp/>the<sp/>Software<sp/>is<sp/>furnished<sp/>to<sp/>do<sp/>so,<sp/>subject<sp/>to<sp/>the<sp/>following<sp/>conditions:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="comment">#<sp/>The<sp/>above<sp/>copyright<sp/>notice<sp/>and<sp/>this<sp/>permission<sp/>notice<sp/>shall<sp/>be<sp/>included<sp/>in<sp/>all<sp/>copies<sp/>or<sp/>substantial<sp/>portions<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="comment">#<sp/>the<sp/>Software.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="comment">#<sp/>THE<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>AS<sp/>IS,<sp/>WITHOUT<sp/>WARRANTY<sp/>OF<sp/>ANY<sp/>KIND,<sp/>EXPRESS<sp/>OR<sp/>IMPLIED,<sp/>INCLUDING<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">#<sp/>THE<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY,<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE<sp/>AND<sp/>NONINFRINGEMENT.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="comment">#<sp/>THE<sp/>AUTHORS<sp/>OR<sp/>COPYRIGHT<sp/>HOLDERS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>CLAIM,<sp/>DAMAGES<sp/>OR<sp/>OTHER<sp/>LIABILITY,<sp/>WHETHER<sp/>IN<sp/>AN<sp/>ACTION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment">#<sp/>OF<sp/>CONTRACT,<sp/>TORT<sp/>OR<sp/>OTHERWISE,<sp/>ARISING<sp/>FROM,<sp/>OUT<sp/>OF<sp/>OR<sp/>IN<sp/>CONNECTION<sp/>WITH<sp/>THE<sp/>SOFTWARE<sp/>OR<sp/>THE<sp/>USE<sp/>OR<sp/>OTHER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">#<sp/>DEALINGS<sp/>IN<sp/>THE<sp/>SOFTWARE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>torch</highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>typing<sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>List,<sp/>Dict,<sp/>Tuple,<sp/>Any,<sp/>Union</highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>transformers<sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>PreTrainedTokenizerBase</highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal">EPSILON<sp/>=<sp/>1e-40</highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a31406026136d3c9b3ec5469bd1e0c0f7" kindref="member">get_tokenizer_alignment_splits</ref>(offset_mapping:<sp/>List[tuple],<sp/>offset_mapping_std:<sp/>List[tuple])<sp/>-&gt;<sp/>Dict[int,<sp/>tuple]:</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="30"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Calculates<sp/>split<sp/>depths<sp/>necessary<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>tokens<sp/>to<sp/>align<sp/>input<sp/>offsets<sp/>to<sp/>standard<sp/>offsets.</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/>Only<sp/>input<sp/>offsets<sp/>may<sp/>be<sp/>split,<sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>standard<sp/>offsets,<sp/>to<sp/>create<sp/>one-to-one,<sp/>one-to-many,<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>many-to-one</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>token<sp/>alignments<sp/>between<sp/>input-to-standard<sp/>tokenization.</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/>Allows<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>multiple<sp/>depth<sp/>splits<sp/>on<sp/>a<sp/>token.</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...].</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...]</highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits<sp/>(:obj:`Dict[int,<sp/>tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>For<sp/>tokens<sp/>that<sp/>have<sp/>to<sp/>be<sp/>split,<sp/>{Token<sp/>index:<sp/>(split<sp/>depth<sp/>1,<sp/>split<sp/>depth<sp/>2,<sp/>...),<sp/>...}.</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="44"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="45"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>splits<sp/>=<sp/>{}</highlight></codeline>
<codeline lineno="46"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>idx<sp/>=<sp/>0<sp/><sp/></highlight><highlight class="comment">#<sp/>index<sp/>of<sp/>token<sp/>segment<sp/>(server<sp/>tokenization)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>idx_std<sp/>=<sp/>0<sp/><sp/></highlight><highlight class="comment">#<sp/>index<sp/>of<sp/>token<sp/>segment<sp/>(standard<sp/>tokenization)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]<sp/><sp/></highlight><highlight class="comment">#<sp/>first<sp/>right<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]<sp/><sp/></highlight><highlight class="comment">#<sp/>first<sp/>std<sp/>right<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="55"><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>1<sp/><sp/></highlight><highlight class="comment">#<sp/>keep<sp/>count<sp/>of<sp/>segments<sp/>traversed,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>1<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>track<sp/>one-to-many,<sp/>many-to-one<sp/>conditions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>right<sp/>&lt;<sp/>right_std:</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Examples:<sp/>[|]<sp/>edge,<sp/>[\]<sp/>next<sp/>edge,<sp/>[.]<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>(45,<sp/>49)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>(45,<sp/>48)<sp/>(48,<sp/>51)<sp/>std</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/>.|<sp/><sp/><sp/><sp/>\</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/>|<sp/><sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>segment_count<sp/>==<sp/>1<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>segment_count_std<sp/>&gt;<sp/>1:<sp/><sp/></highlight><highlight class="comment">#<sp/>prevent<sp/>many-to-many</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>.<sp/>|<sp/><sp/><sp/>\</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/><sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>offset_mapping[idx][0]</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left_std<sp/>=<sp/>offset_mapping_std[idx_std][0]</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits.setdefault(idx,<sp/>[])</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits[idx]<sp/>+=<sp/>[left_std<sp/>-<sp/>left]<sp/><sp/></highlight><highlight class="comment">#<sp/>server<sp/>token,<sp/>split<sp/>depth</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping):</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>right-aligned<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>right_std<sp/>&lt;<sp/>right:</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>segment_count_std<sp/>==<sp/>1<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>segment_count<sp/>&gt;<sp/>1:<sp/><sp/></highlight><highlight class="comment">#<sp/>prevent<sp/>many-to-many</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Examples:<sp/>[|]<sp/>edge,<sp/>[\]<sp/>next<sp/>edge,<sp/>[.]<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/>|<sp/>|<sp/>|<sp/>.<sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/>\</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>(775,<sp/>778,<sp/>781,<sp/>788,<sp/>791)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>(775,<sp/>782,<sp/>785,<sp/>795)<sp/>std</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>|<sp/><sp/>|<sp/><sp/>|.<sp/><sp/>.<sp/>|<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allow<sp/>for<sp/>multiple<sp/>splits<sp/>on<sp/>a<sp/>single<sp/>token</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>|<sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>left<sp/>=<sp/>offset_mapping[idx][0]</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits.setdefault(idx,<sp/>[])</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits[idx]<sp/>+=<sp/>[right_std<sp/>-<sp/>left]<sp/><sp/></highlight><highlight class="comment">#<sp/>server<sp/>token,<sp/>split<sp/>depth</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>right-aligned<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>right<sp/>==<sp/>right_std</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping):</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>right-aligned<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>right-aligned<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>idx<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>splits:</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>splits[idx]<sp/>=<sp/>tuple(splits[idx])<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>enable<sp/>hashable<sp/>depths<sp/>for<sp/>split_map_cache<sp/>keying</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>splits</highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a80673928d5022558ece6eb5cdc9e12be" kindref="member">get_tokenizer_sequence_mappings</ref>(offset_mapping:<sp/>List[tuple],<sp/>offset_mapping_std:<sp/>List[tuple])<sp/>-&gt;<sp/>List[tuple]:</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="143"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Greedily<sp/>determine<sp/>the<sp/>one-to-one,<sp/>one-to-many,<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>many-to-one<sp/>token<sp/>alignments</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/>between<sp/>input-to-standard<sp/>tokenizations.</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/>Disallow<sp/>many-to-many<sp/>mappings,<sp/>but<sp/>allow<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>right-aligned<sp/>overlapping<sp/>tokens.</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...].</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...]</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mappings<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List<sp/>of<sp/>mapping<sp/>tuples:</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[tuple(<sp/>right_idx,<sp/>right_idx_std,</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_base,<sp/>segment_count_std_base,</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap,<sp/>segment_count_std_overlap),<sp/>...]</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="159"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>mappings<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="160"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="161"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>idx<sp/>=<sp/>0<sp/><sp/></highlight><highlight class="comment">#<sp/>index<sp/>of<sp/>token<sp/>segment<sp/>(server<sp/>tokenization)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>idx_std<sp/>=<sp/>0<sp/><sp/></highlight><highlight class="comment">#<sp/>index<sp/>of<sp/>token<sp/>segment<sp/>(standard<sp/>tokenization)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]<sp/><sp/></highlight><highlight class="comment">#<sp/>first<sp/>right<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]<sp/><sp/></highlight><highlight class="comment">#<sp/>first<sp/>std<sp/>right<sp/>edge</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>1<sp/><sp/></highlight><highlight class="comment">#<sp/>keep<sp/>count<sp/>of<sp/>segments<sp/>traversed,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>1<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>track<sp/>one-to-many,<sp/>many-to-one<sp/>conditions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count_overlap<sp/>=<sp/>0<sp/><sp/></highlight><highlight class="comment">#<sp/>keep<sp/>count<sp/>of<sp/>overlapping<sp/>segments</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>segment_count_std_overlap<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="171"><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="176"><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>right<sp/>&lt;<sp/>right_std:</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>segment_count<sp/>==<sp/>1<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>segment_count_std<sp/>&gt;<sp/>1:</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Examples:<sp/>[|]<sp/>edge,<sp/>[\]<sp/>next<sp/>edge,<sp/>[.]<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>.<sp/>|<sp/><sp/><sp/>\</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/>|<sp/>|<sp/>|<sp/><sp/><sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(</highlight><highlight class="stringliteral">&apos;Unaligned:<sp/>Expected<sp/>an<sp/>aligned<sp/>std<sp/>edge.&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(</highlight><highlight class="stringliteral">&apos;idx,<sp/>idx_std,<sp/>right,<sp/>right_std,<sp/>segment_count,<sp/>segment_count_std&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(idx,<sp/>idx_std,<sp/>right,<sp/>right_std,<sp/>segment_count,<sp/>segment_count_std)</highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping):</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="196"><highlight class="normal"></highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>right_std<sp/>&lt;<sp/>right:</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>segment_count_std<sp/>==<sp/>1<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>segment_count<sp/>&gt;<sp/>1:</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Examples:<sp/>[|]<sp/>edge,<sp/>[\]<sp/>next<sp/>edge,<sp/>[.]<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/>|<sp/>|<sp/>|<sp/>.<sp/>|</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/>\</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(</highlight><highlight class="stringliteral">&apos;Unaligned:<sp/>Expected<sp/>an<sp/>aligned<sp/>edge.&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(</highlight><highlight class="stringliteral">&apos;idx,<sp/>idx_std,<sp/>right,<sp/>right_std,<sp/>segment_count,<sp/>segment_count_std&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(idx,<sp/>idx_std,<sp/>right,<sp/>right_std,<sp/>segment_count,<sp/>segment_count_std)</highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>right<sp/>==<sp/>right_std</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mappings<sp/>+=<sp/>[(idx,<sp/>idx_std,<sp/>segment_count,<sp/>segment_count_std,</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap,<sp/>segment_count_std_overlap)]</highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std_overlap<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(offset_mapping):</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right<sp/>=<sp/>offset_mapping[idx][1]</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx_std<sp/>&lt;<sp/>len(offset_mapping_std):</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>right_std<sp/>=<sp/>offset_mapping_std[idx_std][1]</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping[idx<sp/>+<sp/>1][1]<sp/>==<sp/>right):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="242"><highlight class="normal"></highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(idx_std<sp/>+<sp/>1<sp/>&lt;<sp/>len(offset_mapping_std)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std[idx_std<sp/>+<sp/>1][1]<sp/>==<sp/>right_std):<sp/><sp/></highlight><highlight class="comment">#<sp/>ignore<sp/>overlapping<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_std<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std_overlap<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>mappings<sp/>+=<sp/>[(len(offset_mapping),<sp/>len(offset_mapping_std),<sp/>1,<sp/>1,<sp/>0,<sp/>0)]<sp/><sp/></highlight><highlight class="comment">#<sp/>validation<sp/>segment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mappings</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1af76d2962aae10ddc4826d5f349fd9051" kindref="member">get_tokenizer_depth_split_map</ref>(tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>depths:<sp/>tuple)<sp/>-&gt;<sp/>List[Dict[str,<sp/>torch.LongTensor]]:</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="257"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Split<sp/>individual<sp/>token<sp/>strings<sp/>at<sp/>specified<sp/>depths,<sp/>retokenize<sp/>each<sp/>resulting<sp/>segment,</highlight></codeline>
<codeline lineno="258"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>keep<sp/>only<sp/>the<sp/>first<sp/>token<sp/>of<sp/>each<sp/>segment<sp/>(</highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>there<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>one).</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>Purpose<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>to<sp/>provide<sp/>targets<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>scattering<sp/>probabilities<sp/>when<sp/>a<sp/>single<sp/>distribution<sp/>requires<sp/>a<sp/>depth<sp/>split.</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer.</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>depths<sp/>(:obj:`tuple`,<sp/>`required`):</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tuple<sp/>of<sp/>depths<sp/>at<sp/>which<sp/>tokens<sp/>strings<sp/>will<sp/>be<sp/>split.</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map<sp/>(:obj:`List[Dict[str,<sp/>torch.LongTensor]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="269"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>split_map<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="270"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="271"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>phrases<sp/>=<sp/>tokenizer.batch_decode(range(tokenizer.vocab_len))<sp/><sp/></highlight><highlight class="comment">#<sp/>list<sp/>of<sp/>variable<sp/>len<sp/>strings<sp/>(one<sp/>per<sp/>token)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>first<sp/>part<sp/>of<sp/>the<sp/>phrase<sp/>up<sp/>to<sp/>distance<sp/>characters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/>split_phrases<sp/>=<sp/>[[phrase[:depths[0]]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>phrase<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrases]]</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(len(depths)-1):</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>middle<sp/>parts<sp/>of<sp/>the<sp/>phrase<sp/>from<sp/>distance<sp/>characters<sp/>to<sp/>end</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_phrases<sp/>+=<sp/>[[phrase[depths[i]:depths[i+1]]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>phrase<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrases]]</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>right<sp/>part<sp/>of<sp/>the<sp/>phrase<sp/>from<sp/>distance<sp/>characters<sp/>to<sp/>end</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>split_phrases<sp/>+=<sp/>[[phrase[depths[-1]:]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>phrase<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrases]]</highlight></codeline>
<codeline lineno="280"><highlight class="normal"></highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,<sp/>phrases<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(split_phrases):<sp/><sp/></highlight><highlight class="comment">#<sp/>loop<sp/>through<sp/>left,<sp/>middle,<sp/>right<sp/>phrase<sp/>collections</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>side_tokens<sp/>=<sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(phrases)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>tokenize<sp/>phrase<sp/>collection</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_lens<sp/>=<sp/>[len(p)<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>p<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>side_tokens]<sp/><sp/></highlight><highlight class="comment">#<sp/>get<sp/>token<sp/>lengths<sp/>of<sp/>each<sp/>phrase</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>[i<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,<sp/>l<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(tokens_lens)<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>l<sp/>&gt;<sp/>0]<sp/><sp/></highlight><highlight class="comment">#<sp/>only<sp/>non-zero<sp/>len<sp/>tokens<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>first_tokens<sp/>=<sp/>[side_tokens[i][0]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>collect<sp/>first<sp/>tokens<sp/>of<sp/>each<sp/>tokenized<sp/>phrase</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>dict<sp/>for<sp/>phrase<sp/>collection,<sp/>mapping<sp/>from<sp/>original<sp/>index<sp/>to<sp/>first<sp/>tokens<sp/>of<sp/>tokenized<sp/>phrase<sp/>substrings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map<sp/>+=<sp/>[{</highlight><highlight class="stringliteral">&apos;from&apos;</highlight><highlight class="normal">:<sp/>torch.tensor(from_idx,<sp/>dtype=torch.long),</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;to&apos;</highlight><highlight class="normal">:<sp/>torch.tensor(first_tokens,<sp/>dtype=torch.long)}]</highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>split_map</highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1af3a7513c8021247073b9f0f68d3e751a" kindref="member">split_probs</ref>(probs:<sp/>torch.FloatTensor,<sp/>split_map:<sp/>List[Dict[str,<sp/>torch.Tensor]])<sp/>-&gt;<sp/>torch.FloatTensor:</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="295"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Split<sp/>a<sp/>given<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>tokenizer<sp/>vocabulary,<sp/>given<sp/>a<sp/>split_map</highlight></codeline>
<codeline lineno="296"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>of<sp/>mappings<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>original<sp/>tokens<sp/>to<sp/>target<sp/>tokens<sp/>at<sp/>each<sp/>depth<sp/>of<sp/>the<sp/>split.</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[vocab_size]<sp/>Input<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map<sp/>(:obj:`List[Dict[str,<sp/>torch.Tensor]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>split_map<sp/>of<sp/>mappings<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>original<sp/>tokens<sp/>to<sp/>target<sp/>tokens<sp/>at<sp/>each<sp/>depth<sp/>of<sp/>the<sp/>split.</highlight></codeline>
<codeline lineno="302"><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[splits,<sp/>vocab_size]<sp/>A<sp/>new<sp/>tensor<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>resultant<sp/>probability<sp/>distribution<sp/>at<sp/>each<sp/>index</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>of<sp/>the<sp/>first<sp/>dim,<sp/>representing<sp/>corresponding<sp/>split<sp/>depth.</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="308"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>splits<sp/>=<sp/>len(split_map)<sp/><sp/></highlight><highlight class="comment">#<sp/>how<sp/>many<sp/>parts<sp/>to<sp/>the<sp/>depth<sp/>split<sp/>map,<sp/>e.g.<sp/>left,<sp/>middle,<sp/>right<sp/>parts</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/>vocab_size<sp/>=<sp/>probs.shape[0]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>input<sp/>vocabulary<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/>new_probs<sp/>=<sp/>torch.zeros((splits,<sp/>vocab_size)).to(probs.device)<sp/><sp/></highlight><highlight class="comment">#<sp/>provision<sp/>prob<sp/>dist<sp/>for<sp/>each<sp/>part</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>pos<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(splits):<sp/><sp/></highlight><highlight class="comment">#<sp/>loop<sp/>through<sp/>all<sp/>parts<sp/>of<sp/>the<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>split_map[pos][</highlight><highlight class="stringliteral">&apos;from&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>from<sp/>original<sp/>string<sp/>token<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_idx<sp/>=<sp/>split_map[pos][</highlight><highlight class="stringliteral">&apos;to&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>first<sp/>token<sp/>index<sp/>of<sp/>retokenized<sp/>part<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_probs[pos].scatter_add_(0,<sp/>to_idx,<sp/>probs[from_idx])<sp/><sp/></highlight><highlight class="comment">#<sp/>transfer<sp/>probabilities<sp/>to<sp/>new<sp/>part<sp/>distributions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_probs<sp/><sp/></highlight><highlight class="comment">#<sp/>[splits,<sp/>vocab_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8a5ed01b4d5f6883475c9db9f896edbe" kindref="member">align_tokenizer_sequences</ref>(probs:<sp/>torch.FloatTensor,<sp/>offset_mapping:<sp/>List[tuple],<sp/>offset_mapping_std:<sp/>List[tuple],</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache:<sp/>Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]],</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens:<sp/>torch.LongTensor,<sp/>tokens_std:<sp/>torch.LongTensor)<sp/>-&gt;<sp/>Tuple[torch.FloatTensor,</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List[tuple],</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>torch.LongTensor]:</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="327"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Align<sp/>an<sp/>input<sp/>tokenization<sp/>distribution<sp/>to<sp/>standard<sp/>tokenization<sp/>segments<sp/>by<sp/>depth-splitting</highlight></codeline>
<codeline lineno="328"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>the<sp/>input<sp/>distribution<sp/>at<sp/>greedily<sp/>chosen<sp/>locations.<sp/>Prepares<sp/>the<sp/>input<sp/>distribution<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>mapping<sp/>to<sp/>a<sp/>standard</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/>distribution.</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sequence_len,<sp/>vocab_size]<sp/>Input<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...].</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...]</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache<sp/>(:obj:`Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>dictionary<sp/>of<sp/>depths<sp/>keying<sp/>split_maps<sp/>of<sp/>mappings<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>original<sp/>tokens<sp/>to</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>tokens<sp/>at<sp/>each<sp/>depth<sp/>of<sp/>the<sp/>split.</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_std<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[std_sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>standard<sp/>tokenizer.</highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[new_sequence_len,<sp/>vocab_size]<sp/>Aligned<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>aligned<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...].</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_tokens<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>sequence<sp/>of<sp/>aligned<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="355"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>aligned_tokens<sp/>=<sp/>[]<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>store<sp/>new<sp/>aligned<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_probs<sp/>=<sp/>[]<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>store<sp/>new<sp/>aligned<sp/>probability<sp/>distributions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>=<sp/>[]<sp/><sp/></highlight><highlight class="comment">#<sp/>to<sp/>store<sp/>new<sp/>aligned<sp/>offset<sp/>mappings<sp/>of<sp/>aligned<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/>splits<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a31406026136d3c9b3ec5469bd1e0c0f7" kindref="member">get_tokenizer_alignment_splits</ref>(offset_mapping,<sp/>offset_mapping_std)<sp/><sp/></highlight><highlight class="comment">#<sp/>get<sp/>necessary<sp/>token<sp/>split<sp/>locations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/>prev_idx<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>idx<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>splits:<sp/><sp/></highlight><highlight class="comment">#<sp/>each<sp/>source<sp/>token<sp/>index<sp/>that<sp/>must<sp/>be<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>depths<sp/>=<sp/>splits[idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>list<sp/>of<sp/>depths<sp/>at<sp/>which<sp/>the<sp/>token<sp/>string<sp/>must<sp/>be<sp/>split</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_probs<sp/>+=<sp/>[probs[prev_idx:idx]]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>preceding<sp/>token<sp/>probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>+=<sp/>offset_mapping[prev_idx:idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>preceding<sp/>offset<sp/>mappings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_tokens<sp/>+=<sp/>[tokens[prev_idx:idx]]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>preceding<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>depths<sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>split_map_cache:</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>depths<sp/>split<sp/>to<sp/>cache<sp/>to<sp/>reuse<sp/>in<sp/>future<sp/>(split<sp/>map<sp/>calc<sp/>is<sp/>relatively<sp/>time-consuming)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache[depths]<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1af76d2962aae10ddc4826d5f349fd9051" kindref="member">get_tokenizer_depth_split_map</ref>(tokenizer,<sp/>depths)</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_probs<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1af3a7513c8021247073b9f0f68d3e751a" kindref="member">split_probs</ref>(probs[idx],<sp/>split_map_cache[depths])<sp/><sp/></highlight><highlight class="comment">#<sp/>[splits,<sp/>vocab_size]<sp/>new<sp/>split<sp/>probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_probs<sp/>+=<sp/>[new_probs]</highlight></codeline>
<codeline lineno="373"><highlight class="normal"></highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>text_idx<sp/>=<sp/>tokenizer.decode(tokens[idx])</highlight></codeline>
<codeline lineno="375"><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Left<sp/>part<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_tokens<sp/>=<sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(text_idx[:depths[0]],<sp/>add_special_tokens=</highlight><highlight class="keyword">False</highlight><highlight class="normal">,<sp/>return_tensors=</highlight><highlight class="stringliteral">&apos;pt&apos;</highlight><highlight class="normal">)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">][0]</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_tokens<sp/>+=<sp/>[new_tokens[:1]]</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>+=<sp/>[(offset_mapping[idx][0],<sp/>offset_mapping[idx][0]<sp/>+<sp/>depths[0])]</highlight></codeline>
<codeline lineno="380"><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Middle<sp/>parts<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>d<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(len(depths)-1):</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_tokens<sp/>=<sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(text_idx[depths[d]:depths[d+1]],</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>add_special_tokens=</highlight><highlight class="keyword">False</highlight><highlight class="normal">,<sp/>return_tensors=</highlight><highlight class="stringliteral">&apos;pt&apos;</highlight><highlight class="normal">)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">][0]</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_tokens<sp/>+=<sp/>[new_tokens[:1]]</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>+=<sp/>[(offset_mapping[idx][0]<sp/>+<sp/>depths[d],<sp/>offset_mapping[idx][0]<sp/>+<sp/>depths[d+1])]</highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>==<sp/>Right<sp/>part<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_tokens<sp/>=<sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(text_idx[depths[-1]:],<sp/>add_special_tokens=</highlight><highlight class="keyword">False</highlight><highlight class="normal">,<sp/>return_tensors=</highlight><highlight class="stringliteral">&apos;pt&apos;</highlight><highlight class="normal">)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">][0]</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_tokens<sp/>+=<sp/>[new_tokens[:1]]</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>+=<sp/>[(offset_mapping[idx][0]<sp/>+<sp/>depths[-1],<sp/>offset_mapping[idx][1])]</highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prev_idx<sp/>=<sp/>idx<sp/>+<sp/>1</highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_probs<sp/>+=<sp/>[probs[prev_idx:]]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>remainder<sp/>of<sp/>tokens<sp/>probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_tokens<sp/>+=<sp/>[tokens[prev_idx:]]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>remainder<sp/>of<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_offset_mapping<sp/>+=<sp/>offset_mapping[prev_idx:]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>remainder<sp/>of<sp/>offset<sp/>mappings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_probs<sp/>=<sp/>torch.cat(aligned_probs,<sp/>dim=0)<sp/><sp/></highlight><highlight class="comment">#<sp/>[sequence_len,<sp/>vocab_size]<sp/>assemble<sp/>final<sp/>probability<sp/>tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_tokens<sp/>=<sp/>torch.cat(aligned_tokens,<sp/>dim=0).long()<sp/><sp/></highlight><highlight class="comment">#<sp/>[sequence_len]<sp/>assemble<sp/>final<sp/>token<sp/>sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>aligned_probs,<sp/>aligned_offset_mapping,<sp/>aligned_tokens</highlight></codeline>
<codeline lineno="403"><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">get_translation_map(from_tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer:<sp/>PreTrainedTokenizerBase)<sp/>-&gt;<sp/>Dict[str,<sp/>Any]:</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="408"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Map<sp/>individual<sp/>token<sp/>phrases<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>a<sp/>tokenizer<sp/>to<sp/>another<sp/>tokenizer.</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>From<sp/>tokenizer.</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>To<sp/>tokenizer.</highlight></codeline>
<codeline lineno="414"><highlight class="normal"></highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>source<sp/>index<sp/>to<sp/>target<sp/>indices.</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="420"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(from_tokenizer)</highlight></codeline>
<codeline lineno="421"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(to_tokenizer)</highlight></codeline>
<codeline lineno="422"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="423"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>translation_map<sp/>=<sp/>{&apos;lengths&apos;</highlight><highlight class="normal">:<sp/>{}}</highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/>phrases<sp/>=<sp/>from_tokenizer.batch_decode(range(from_tokenizer.vocab_len))<sp/><sp/></highlight><highlight class="comment">#<sp/>tokens<sp/>to<sp/>strings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/>to_tokens<sp/>=<sp/>to_tokenizer(phrases)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>convert<sp/>single<sp/>token<sp/>from-phrases<sp/>to<sp/>to-tokenization</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/>to_tokens_lens<sp/>=<sp/>[len(p)<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>p<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>to_tokens]</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/>unique_lens<sp/>=<sp/>set(to_tokens_lens)</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/>max_len<sp/>=<sp/>max(unique_lens)</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/>counts<sp/>=<sp/>torch.zeros((max_len,<sp/>to_tokenizer.vocab_len),<sp/>dtype=torch.long)</highlight></codeline>
<codeline lineno="432"><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>l<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>unique_lens:<sp/><sp/></highlight><highlight class="comment">#<sp/>each<sp/>unique<sp/>one-to-many<sp/>mapping<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>[i<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i,<sp/>k<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>enumerate(to_tokens_lens)<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>k<sp/>==<sp/>l]<sp/><sp/></highlight><highlight class="comment">#<sp/>find<sp/>len<sp/>l<sp/>to-tokenizations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subset<sp/>=<sp/>[to_tokens[i]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>find<sp/>len<sp/>l<sp/>to-tokenizations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>torch.tensor(from_idx,<sp/>dtype=torch.long)<sp/><sp/></highlight><highlight class="comment">#<sp/>[subset_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_idx<sp/>=<sp/>torch.tensor(subset,<sp/>dtype=torch.long)<sp/><sp/></highlight><highlight class="comment">#<sp/>[subset_size,<sp/>l]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">][l]<sp/>=<sp/>{</highlight><highlight class="stringliteral">&apos;from&apos;</highlight><highlight class="normal">:<sp/>from_idx,</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;to&apos;</highlight><highlight class="normal">:<sp/>to_idx}</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>counts<sp/>on<sp/>tokens,<sp/>to<sp/>be<sp/>used<sp/>to<sp/>divide<sp/>probability<sp/>mass<sp/>over<sp/>its<sp/>channeled<sp/>sequences</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>counts[:l,<sp/>:].scatter_add_(1,<sp/>to_idx.T,<sp/>torch.ones((l,<sp/>len(subset)),<sp/>dtype=torch.long))</highlight></codeline>
<codeline lineno="442"><highlight class="normal"></highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/>translation_map[</highlight><highlight class="stringliteral">&apos;counts&apos;</highlight><highlight class="normal">]<sp/>=<sp/>counts</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>translation_map</highlight></codeline>
<codeline lineno="445"><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a127face1324f46e879f92ee881771d90" kindref="member">translate_one_to_many</ref>(probs_from:<sp/>torch.FloatTensor,<sp/>probs_to:<sp/>torch.FloatTensor,</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map:<sp/>Dict[str,<sp/>Any])<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="450"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Translate<sp/>a<sp/>single<sp/>token<sp/>probability<sp/>distribution<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>a<sp/>source<sp/>tokenization<sp/>to<sp/>a</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/>sequence<sp/>of<sp/>probability<sp/>distributions<sp/>over<sp/>a<sp/>target<sp/>tokenization.</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_from<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[vocab_size]<sp/>Input<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal">-tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_to<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[many,<sp/>vocab_size]<sp/>Output<sp/>probability<sp/>distributions<sp/>over<sp/>a<sp/>to-tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>source<sp/>index<sp/>to<sp/>target<sp/>indices.</highlight></codeline>
<codeline lineno="460"><highlight class="normal"></highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="462"><highlight class="normal"></highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="464"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>many_len<sp/>=<sp/>probs_to.shape[0]</highlight></codeline>
<codeline lineno="465"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="466"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Unroll<sp/>single<sp/>distribution<sp/>into<sp/>std<sp/>sequence<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(many_len):<sp/><sp/></highlight><highlight class="comment">#<sp/>each<sp/>unrolling<sp/>step</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>map_len<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">].keys():<sp/><sp/></highlight><highlight class="comment">#<sp/>each<sp/>one-to-many<sp/>mapping<sp/>length<sp/>available</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>map_len<sp/>&lt;<sp/>i<sp/>+<sp/>1:</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">#<sp/>skip<sp/>unrolling<sp/>steps<sp/>not<sp/>available<sp/>in<sp/>a<sp/>shorter<sp/>mapping<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">][map_len][</highlight><highlight class="stringliteral">&apos;from&apos;</highlight><highlight class="normal">]</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_idx<sp/>=<sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">][map_len][</highlight><highlight class="stringliteral">&apos;to&apos;</highlight><highlight class="normal">].T<sp/><sp/></highlight><highlight class="comment">#<sp/>[map_len,<sp/>subset_size_std]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_to[i,<sp/>:].scatter_add_(0,<sp/>to_idx[i,<sp/>:],<sp/>probs_from[from_idx])<sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>probs<sp/>in-place</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="474"><highlight class="normal"></highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight></codeline>
<codeline lineno="476"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aacc9d76a7e49b18c20a5b44beafb8306" kindref="member">translate_many_to_one</ref>(probs_from:<sp/>torch.FloatTensor,<sp/>probs_to:<sp/>torch.FloatTensor,</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map:<sp/>Dict[str,<sp/>Any])<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="479"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Translate<sp/>a<sp/>sequence<sp/>of<sp/>token<sp/>probability<sp/>distributions<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>a<sp/>source<sp/>tokenization<sp/>to<sp/>a</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>single<sp/>token<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>target<sp/>tokenization.</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_from<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[many,<sp/>vocab_size]<sp/>Input<sp/>probability<sp/>distributions<sp/>over<sp/>a<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal">-tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_to<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[vocab_size]<sp/>Output<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>to-tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>source<sp/>index<sp/>to<sp/>target<sp/>indices.</highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="493"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>many_len<sp/>=<sp/>probs_from.shape[0]</highlight></codeline>
<codeline lineno="494"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>probs_from_copy<sp/>=<sp/>probs_from.clone()<sp/><sp/></highlight><highlight class="comment">#<sp/>will<sp/>modify<sp/>from-probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Spread<sp/>probability<sp/>mass<sp/>over<sp/>realized<sp/>sequences<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/>counts<sp/>=<sp/>translation_map[</highlight><highlight class="stringliteral">&apos;counts&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>[max_len,<sp/>vocab_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>translation_max_len<sp/>=<sp/>counts.shape[0]<sp/><sp/></highlight><highlight class="comment">#<sp/>maximum<sp/>possible<sp/>many-to-one<sp/>length<sp/>available<sp/>in<sp/>translation<sp/>map</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"></highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>many_len<sp/>&lt;=<sp/>translation_max_len:</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_from_copy<sp/>/=<sp/>counts[:many_len,<sp/>:]<sp/><sp/></highlight><highlight class="comment">#<sp/>divide<sp/>probability<sp/>mass<sp/>by<sp/>amount<sp/>of<sp/>paths<sp/>crossing<sp/>each<sp/>token</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>limit<sp/>probs_from<sp/>token<sp/>depth<sp/>to<sp/>max_len</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_from_copy[:translation_max_len,<sp/>:]<sp/>/=<sp/>counts</highlight></codeline>
<codeline lineno="504"><highlight class="normal"></highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Reverse<sp/>map<sp/>std<sp/>token<sp/>to<sp/>source<sp/>sequences,<sp/>gather<sp/>avg.<sp/>sequence<sp/>prob<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>map_len<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">].keys():<sp/><sp/></highlight><highlight class="comment">#<sp/>mutually<sp/>exclusive<sp/>over<sp/>std<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_idx<sp/>=<sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">][map_len][</highlight><highlight class="stringliteral">&apos;from&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>[subset_size_std]<sp/>one<sp/>std<sp/>token</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_idx<sp/>=<sp/>translation_map[</highlight><highlight class="stringliteral">&apos;lengths&apos;</highlight><highlight class="normal">][map_len][</highlight><highlight class="stringliteral">&apos;to&apos;</highlight><highlight class="normal">].T<sp/><sp/></highlight><highlight class="comment">#<sp/>[map_len,<sp/>subset_size_std]<sp/>many<sp/>server<sp/>token<sp/>seq</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>many_len<sp/>&lt;<sp/>map_len:<sp/><sp/></highlight><highlight class="comment">#<sp/>sequence<sp/>beyond<sp/>segment_count<sp/>has<sp/>min<sp/>probability<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_idx<sp/>=<sp/>to_idx[:many_len,<sp/>:]<sp/><sp/></highlight><highlight class="comment">#<sp/>[segment_count,<sp/>subset_size_std]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>server_seq_tokens<sp/>=<sp/>probs_from_copy.gather(1,<sp/>to_idx)<sp/><sp/></highlight><highlight class="comment">#<sp/>[map_len,<sp/>subset_size_std]<sp/>gather<sp/>sequences</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_to[from_idx]<sp/>=<sp/>server_seq_tokens.sum(dim=0)<sp/>/<sp/>map_len<sp/><sp/></highlight><highlight class="comment">#<sp/>[subset_size_std]<sp/>in-place<sp/>average<sp/>approx.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"></highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1ac2ac0a649cfc204c56ad13913288a4f4" kindref="member">translate_tokenizer_probs</ref>(probs:<sp/>torch.FloatTensor,<sp/>probs_std:<sp/>torch.FloatTensor,</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping:<sp/>List[tuple],<sp/>offset_mapping_std:<sp/>List[tuple],</highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer:<sp/>PreTrainedTokenizerBase,<sp/>std_tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache:<sp/>Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]],</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_translation_map:<sp/>Dict[str,<sp/>Any],<sp/>from_translation_map:<sp/>Dict[str,<sp/>Any],</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens:<sp/>torch.LongTensor,<sp/>tokens_std:<sp/>torch.LongTensor)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="522"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Translates<sp/>source<sp/>token<sp/>probability<sp/>distributions<sp/>to<sp/>target<sp/>probability<sp/>distributions,<sp/>by</highlight></codeline>
<codeline lineno="523"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>aligning<sp/>segments<sp/>through<sp/>source<sp/>token<sp/>splits,<sp/>then<sp/>greedily<sp/>performing<sp/>one-to-one,</highlight></codeline>
<codeline lineno="524"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>one-to-many,<sp/>many-to-one<sp/>distribution<sp/>mappings.</highlight></codeline>
<codeline lineno="525"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="526"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="527"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sequence_len,<sp/>vocab_size]<sp/>Input<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>source<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="528"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_std<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="529"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[std_sequence_len,<sp/>std_vocab_size]<sp/>Output<sp/>probability<sp/>distribution<sp/>over<sp/>a<sp/>target<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="530"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Reference<sp/>that<sp/>will<sp/>be<sp/>written<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal">-place.</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...].</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std<sp/>(:obj:`List[tuple]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>tokenizer<sp/>offset<sp/>mappings<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>a<sp/>specific<sp/>sequence<sp/>[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...]</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard/target<sp/>tokenizer.</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache<sp/>(:obj:`Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>dictionary<sp/>of<sp/>depths<sp/>keying<sp/>split_maps<sp/>of<sp/>mappings<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>original<sp/>tokens<sp/>to</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>tokens<sp/>at<sp/>each<sp/>depth<sp/>of<sp/>the<sp/>split.<sp/>Adds<sp/>split_maps<sp/>to<sp/>cache<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>faster<sp/>future<sp/>recall.</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_std<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[std_sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>standard<sp/>tokenizer.</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>source<sp/>index<sp/>to<sp/>target<sp/>indices.</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>target<sp/>index<sp/>to<sp/>source<sp/>indices.</highlight></codeline>
<codeline lineno="552"><highlight class="normal"></highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="554"><highlight class="normal"></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="556"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Align<sp/>tokenized<sp/>sequences<sp/>via<sp/>source<sp/>token<sp/>splitting<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/>result<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8a5ed01b4d5f6883475c9db9f896edbe" kindref="member">align_tokenizer_sequences</ref>(probs,<sp/>offset_mapping,<sp/>offset_mapping_std,</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer,<sp/>split_map_cache,<sp/>tokens.cpu(),<sp/>tokens_std.cpu())</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/>aligned_probs,<sp/>aligned_offset_mapping,<sp/>aligned_tokens<sp/>=<sp/>result</highlight></codeline>
<codeline lineno="560"><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Get<sp/>one-to-many<sp/>/<sp/>many-to-one<sp/>mappings<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/>mappings<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a80673928d5022558ece6eb5cdc9e12be" kindref="member">get_tokenizer_sequence_mappings</ref>(aligned_offset_mapping,<sp/>offset_mapping_std)</highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Perform<sp/>probability<sp/>mappings<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(right_idx,<sp/>right_idx_std,<sp/>segment_count_base,<sp/>segment_count_std_base,</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_overlap,<sp/>segment_count_std_overlap)<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>mappings[1:]:<sp/><sp/></highlight><highlight class="comment">#<sp/>don&apos;t<sp/>map<sp/>start<sp/>token</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count<sp/>=<sp/>segment_count_base<sp/>+<sp/>segment_count_overlap<sp/><sp/></highlight><highlight class="comment">#<sp/>calculate<sp/>effective<sp/>segments<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segment_count_std<sp/>=<sp/>segment_count_std_base<sp/>+<sp/>segment_count_std_overlap<sp/><sp/></highlight><highlight class="comment">#<sp/>calculate<sp/>effective<sp/>segments<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="570"><highlight class="normal"></highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>One-to-many<sp/>/<sp/>one-to-one<sp/>mapping<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>segment_count_base<sp/>==<sp/>1:</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start_idx_std<sp/>=<sp/>right_idx_std<sp/>-<sp/>segment_count_std<sp/><sp/></highlight><highlight class="comment">#<sp/>calculate<sp/>starting<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="574"><highlight class="normal"></highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a127face1324f46e879f92ee881771d90" kindref="member">translate_one_to_many</ref>(aligned_probs[right_idx-1],</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_std[start_idx_std:start_idx_std+segment_count_std],</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_translation_map)</highlight></codeline>
<codeline lineno="578"><highlight class="normal"></highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Many-to-one<sp/>mapping<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>segment_count_std_base<sp/>==<sp/>1:<sp/><sp/></highlight><highlight class="comment">#<sp/>many-to-one</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start_idx<sp/>=<sp/>right_idx<sp/>-<sp/>segment_count<sp/><sp/></highlight><highlight class="comment">#<sp/>calculate<sp/>starting<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="582"><highlight class="normal"></highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aacc9d76a7e49b18c20a5b44beafb8306" kindref="member">translate_many_to_one</ref>(aligned_probs[start_idx:right_idx],</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_std[right_idx_std-1],</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_translation_map)</highlight></codeline>
<codeline lineno="586"><highlight class="normal"></highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>print(</highlight><highlight class="stringliteral">&apos;Undefined<sp/>mapping.&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="589"><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal"></highlight></codeline>
<codeline lineno="591"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aa9eb42e9db4c2b1517d8ff7105c8ebd2" kindref="member">get_top_probs</ref>(probs:<sp/>torch.FloatTensor,<sp/>tokenizer:<sp/>PreTrainedTokenizerBase,<sp/>amount:<sp/>int<sp/>=<sp/>10)<sp/>-&gt;<sp/>str:</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="593"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Constructs<sp/>output<sp/>string<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>top<sp/>amount<sp/>of<sp/>highest<sp/>probability<sp/>token<sp/>strings.</highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/>Used<sp/>to<sp/>display<sp/>the<sp/>top<sp/>probabilities.</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[vocab_size]<sp/>Probability<sp/>distribution<sp/>over<sp/>a<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer.</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>amount:<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Amount<sp/>of<sp/>top<sp/>tokens<sp/>to<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="602"><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>(:obj:`str`,<sp/>`required`):</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Highest<sp/>probability<sp/>token<sp/>strings,<sp/>prob[token-string]<sp/>...</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="607"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>string<sp/>=<sp/>&apos;&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="608"><highlight class="normal"></highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/>vals,<sp/>indices<sp/>=<sp/>probs.sort(dim=-1,<sp/>descending=</highlight><highlight class="keyword">True</highlight><highlight class="normal">)<sp/><sp/></highlight><highlight class="comment">#<sp/>descending<sp/>sort<sp/>token<sp/>probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(amount):</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>+=<sp/></highlight><highlight class="stringliteral">&apos;%.4f[%s]<sp/>&apos;</highlight><highlight class="normal"><sp/>%<sp/>(vals[i],<sp/>tokenizer.decode(indices[i]))<sp/><sp/></highlight><highlight class="comment">#<sp/>prob[token-string]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>string</highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"></highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">translate_logits_to_probs_std(logits:<sp/>torch.FloatTensor,</highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping:<sp/>List[List[tuple]],<sp/>offset_mapping_std:<sp/>List[List[tuple]],</highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer:<sp/>PreTrainedTokenizerBase,<sp/>std_tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache:<sp/>Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]],</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_translation_map:<sp/>Dict[str,<sp/>Any],<sp/>from_translation_map:<sp/>Dict[str,<sp/>Any],</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens:<sp/>torch.LongTensor,<sp/>tokens_std:<sp/>torch.LongTensor,</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skip_equivalent:<sp/>bool<sp/>=<sp/></highlight><highlight class="keyword">True</highlight><highlight class="normal">)<sp/>-&gt;<sp/>torch.FloatTensor:</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="625"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Translates<sp/>source<sp/>token<sp/>logit<sp/>scores<sp/>to<sp/>probability<sp/>distributions<sp/>over<sp/>the<sp/>standard<sp/>tokenizer.</highlight></codeline>
<codeline lineno="626"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="627"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>logits<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="628"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>sequence_len,<sp/>vocab_size]<sp/>Input<sp/>source<sp/>logits<sp/>over<sp/>a<sp/>source<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="629"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping<sp/>(:obj:`List[List[tuple]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="630"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>tokenizer<sp/>offset<sp/>mappings</highlight></codeline>
<codeline lineno="631"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="632"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset_mapping_std<sp/>(:obj:`List[List[tuple]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="633"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>standard<sp/>tokenizer<sp/>offset<sp/>mappings</highlight></codeline>
<codeline lineno="634"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="635"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="636"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="637"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="638"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard/target<sp/>tokenizer.</highlight></codeline>
<codeline lineno="639"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache<sp/>(:obj:`Dict[tuple,<sp/>List[Dict[str,<sp/>torch.Tensor]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="640"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A<sp/>dictionary<sp/>of<sp/>depths<sp/>keying<sp/>split_maps<sp/>of<sp/>mappings<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>original<sp/>tokens<sp/>to</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>tokens<sp/>at<sp/>each<sp/>depth<sp/>of<sp/>the<sp/>split.<sp/>Adds<sp/>split_maps<sp/>to<sp/>cache<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>faster<sp/>future<sp/>recall.</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>source<sp/>tokenizer.</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_std<sp/>(:obj:`torch.LongTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>std_sequence_len]<sp/>A<sp/>sequence<sp/>of<sp/>tokens<sp/>produced<sp/>by<sp/>the<sp/>standard<sp/>tokenizer.</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>source<sp/>index<sp/>to<sp/>target<sp/>indices.</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_translation_map<sp/>(:obj:`Dict[str,<sp/>Any]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Maps<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>observed<sp/>length,<sp/>a<sp/>source<sp/>token<sp/>to<sp/>a<sp/>token<sp/>sequence<sp/>of<sp/>that<sp/>length,</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>target<sp/>index<sp/>to<sp/>source<sp/>indices.</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>skip_equivalent<sp/>(:obj:`bool`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Skips<sp/>translation<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>std_tokenizer<sp/>are<sp/>equivalent.</highlight></codeline>
<codeline lineno="654"><highlight class="normal"></highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_std<sp/>(:obj:`torch.FloatTensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>std_sequence_len,<sp/>std_vocab_size]<sp/>Output<sp/>probability<sp/>distribution<sp/>over<sp/>the</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>standard<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="660"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(tokenizer)</highlight></codeline>
<codeline lineno="661"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(std_tokenizer)</highlight></codeline>
<codeline lineno="662"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="663"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Check<sp/>tokenizer<sp/>equivalence<sp/>/<sp/>Skip<sp/>if<sp/>equivalent<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>skip_equivalent<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a54a25644b9cfa6b662c66e0707692a72" kindref="member">check_tokenizer_equivalence</ref>(tokenizer,<sp/>std_tokenizer):</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>logits<sp/>=<sp/>logits.to(torch.float).to(</highlight><highlight class="stringliteral">&apos;cpu&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>torch.softmax(logits,<sp/>dim=2)</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>probs</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Get<sp/>shape<sp/>sizes<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/>batch_size,<sp/>sequence_len,<sp/>vocab_size<sp/>=<sp/>logits.shape</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/>std_sequence_len<sp/>=<sp/>tokens_std.shape[-1]</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/>std_vocab_size<sp/>=<sp/>std_tokenizer.vocab_len</highlight></codeline>
<codeline lineno="673"><highlight class="normal"></highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer.vocab_len<sp/>&lt;<sp/>vocab_size:</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>logits<sp/>=<sp/>logits[...,<sp/>:tokenizer.vocab_len]</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vocab_size<sp/>=<sp/>tokenizer.vocab_len</highlight></codeline>
<codeline lineno="677"><highlight class="normal"></highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Convert<sp/>logits<sp/>to<sp/>probabilities<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/>logits<sp/>=<sp/>logits.to(torch.float).to(</highlight><highlight class="stringliteral">&apos;cpu&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>torch.softmax(logits,<sp/>dim=2)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>sequence_len,<sp/>vocab_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"></highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>vocab_size<sp/>&lt;<sp/>tokenizer.vocab_len:<sp/><sp/></highlight><highlight class="comment">#<sp/>fixes<sp/>bug<sp/>when<sp/>model<sp/>logits<sp/>output<sp/>is<sp/>not<sp/>full<sp/>width</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>padded_probs<sp/>=<sp/>torch.zeros((batch_size,<sp/>sequence_len,<sp/>tokenizer.vocab_len))</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>padded_probs[...,<sp/>:vocab_size]<sp/>=<sp/>probs</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>padded_probs</highlight></codeline>
<codeline lineno="686"><highlight class="normal"></highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Translate<sp/>to<sp/>probabilities<sp/>over<sp/>standard<sp/>tokenizer<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_std<sp/>=<sp/>torch.zeros(batch_size,<sp/>std_sequence_len,<sp/>std_vocab_size)</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>b<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(batch_size):</highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs_b<sp/>=<sp/>probs[b][-len(offset_mapping[b]):]<sp/><sp/></highlight><highlight class="comment">#<sp/>remove<sp/>left<sp/>padding</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_b<sp/>=<sp/>tokens[b][-len(offset_mapping[b]):]<sp/><sp/></highlight><highlight class="comment">#<sp/>remove<sp/>left<sp/>padding</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1ac2ac0a649cfc204c56ad13913288a4f4" kindref="member">translate_tokenizer_probs</ref>(probs_b,<sp/>probs_std[b],<sp/>offset_mapping[b],<sp/>offset_mapping_std[b],</highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer,<sp/>std_tokenizer,</highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>split_map_cache,<sp/>to_translation_map,<sp/>from_translation_map,</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens_b,<sp/>tokens_std[b])</highlight></codeline>
<codeline lineno="696"><highlight class="normal"></highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Correct<sp/>excess<sp/>probability<sp/>mass<sp/>(haircut)<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_std_sum<sp/>=<sp/>probs_std.sum(dim=-1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>std_sequence_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/>over<sp/>=<sp/>(probs_std_sum<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_std[over]<sp/>/=<sp/>probs_std_sum[over][:,<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">]</highlight></codeline>
<codeline lineno="701"><highlight class="normal"></highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Correct<sp/>deficient<sp/>probability<sp/>mass<sp/>(raise)<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_std_sum<sp/>=<sp/>probs_std.sum(dim=-1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>std_sequence_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/>under<sp/>=<sp/>(probs_std_sum<sp/>&lt;<sp/>1)</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_std[under]<sp/>+=<sp/>((1<sp/>-<sp/>probs_std_sum[under])<sp/>/<sp/>probs_std[under].shape[-1])[:,<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>raise<sp/>noise<sp/>floor<sp/>so<sp/>sum<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="706"><highlight class="normal"></highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>probs_std<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>std_sequence_len,<sp/>std_vocab_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="708"><highlight class="normal"></highlight></codeline>
<codeline lineno="709"><highlight class="normal"></highlight></codeline>
<codeline lineno="710"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">topk_token_phrases(logits:<sp/>torch.Tensor,<sp/>tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk:<sp/>int,<sp/>ignore_index:<sp/>int<sp/>=<sp/>-100)<sp/>-&gt;<sp/>torch.Tensor:</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="713"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Select<sp/>topk<sp/>tokenizer<sp/>logits/phrases<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>include<sp/>std_token_phrases<sp/>counterparts<sp/>(std_tokenization<sp/>of<sp/>token<sp/>text)</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>topk_tensor<sp/>output<sp/>of<sp/>shape<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len],<sp/>where<sp/>max<sp/>len<sp/>of<sp/>all<sp/>phrase<sp/>lists</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/>(</highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>prob<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>front)<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>max_{b,k}(len([prob_k,<sp/>tok_0_k,<sp/>tok_1_k,<sp/>...])).</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>The<sp/>output<sp/>topk_tensor<sp/>also<sp/>includes<sp/>a<sp/>floor_prob<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>each<sp/>batch<sp/>item.<sp/>The<sp/>floor<sp/>probability<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>the</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/>mean<sp/>probability<sp/>of<sp/>token<sp/>phrases<sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>captured<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>topk,<sp/>required<sp/>since<sp/>the<sp/>tokenizer<sp/>vocab_size<sp/>may</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>be<sp/>known<sp/>to<sp/>the<sp/>receiver.</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/>Requires<sp/>prep_tokenizer(tokenizer,<sp/>std_tokenizer)<sp/>to<sp/>set_std_token_phrases<sp/>first,<sp/>to<sp/>make</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/>std_token_phrases<sp/>available<sp/>here.</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>logits<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>vocab_size]<sp/>Input<sp/>source<sp/>logits<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>last<sp/>token<sp/>over<sp/>a<sp/>source<sp/>tokenizer<sp/>vocabulary.</highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source<sp/>tokenizer<sp/>(usually<sp/>server<sp/>tokenizer)</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk<sp/>(:obj:`int`,<sp/>`required`):</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Amount<sp/>of<sp/>top<sp/>phrases<sp/>to<sp/>expect<sp/>(to<sp/>check<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>mismatch)</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ignore_index<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Padding<sp/>value<sp/>to<sp/>use<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>unfilled<sp/>token<sp/>positions<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>a<sp/>shorter<sp/>token<sp/>phrase.</highlight></codeline>
<codeline lineno="730"><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>tensor<sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>tok_1_k=1_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=0,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>tok_1_k=1_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=1,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...]]</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="746"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Get<sp/>shape<sp/>sizes</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/>batch_size,<sp/>vocab_size<sp/>=<sp/>logits.shape<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>vocab_size]<sp/>only<sp/>last<sp/>token<sp/>prediction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="748"><highlight class="normal"></highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Convert<sp/>logits<sp/>to<sp/>probabilities</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/>logits<sp/>=<sp/>logits.float()<sp/><sp/></highlight><highlight class="comment">#<sp/>ensure<sp/>further<sp/>computations<sp/>done<sp/>in<sp/>float32<sp/>for<sp/>improved<sp/>precision</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>torch.softmax(logits,<sp/>dim=1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>vocab_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="752"><highlight class="normal"></highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>TopK<sp/>phrase<sp/>selection</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs,<sp/>topk_indices<sp/>=<sp/>torch.topk(probs,<sp/>topk)<sp/><sp/></highlight><highlight class="comment">#<sp/>topk<sp/>probs<sp/>and<sp/>indices:<sp/>[batch_size,<sp/>topk]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="755"><highlight class="normal"></highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Calculate<sp/>floor<sp/>probability<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="757"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_pmass<sp/>=<sp/>topk_probs.sum(dim=-1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>topk<sp/>probability<sp/>mass</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/>remainder_pmass<sp/>=<sp/>torch.clamp(1<sp/>-<sp/>topk_pmass,<sp/>1e-40,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>remainder<sp/>probability<sp/>mass</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs<sp/>=<sp/>remainder_pmass<sp/>/<sp/>(vocab_size<sp/>-<sp/>topk)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]divide<sp/>remainder</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="760"><highlight class="normal"></highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>convert<sp/>to<sp/>list<sp/>for<sp/>faster<sp/>iteration<sp/>in<sp/>list<sp/>comprehension</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="762"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs_list<sp/>=<sp/>topk_probs.tolist()</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_indices_list<sp/>=<sp/>topk_indices.tolist()</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs_list<sp/>=<sp/>floor_probs.tolist()</highlight></codeline>
<codeline lineno="765"><highlight class="normal"></highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Construct<sp/>topk<sp/>phrases<sp/>list<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>[]<sp/><sp/></highlight><highlight class="comment">#<sp/>collect<sp/>probability<sp/>tensors<sp/>with<sp/>gradients<sp/>attached<sp/>(to<sp/>be<sp/>grafted<sp/>into<sp/>topk_tensor)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/>phrases<sp/>=<sp/>[]<sp/><sp/></highlight><highlight class="comment">#<sp/>form<sp/>topk<sp/>token<sp/>phrases<sp/>with<sp/>prob<sp/>prepend<sp/>[prob,<sp/>tok_0,<sp/>tok_1,<sp/>...<sp/>tok_n]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="769"><highlight class="normal"></highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>b<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(batch_size):</highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>collect<sp/>probability<sp/>tensors<sp/>with<sp/>gradients<sp/>attached<sp/>(to<sp/>be<sp/>grafted<sp/>into<sp/>topk_tensor)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>probs<sp/>+=<sp/>[topk_probs[b],<sp/>floor_probs[b]]<sp/><sp/></highlight><highlight class="comment">#<sp/>[tensor(prob_k=0_b,<sp/>prob_k=1_b,<sp/>...),<sp/>tensor(prob_floor_b)]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="773"><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>form<sp/>topk<sp/>token<sp/>phrases<sp/>with<sp/>prob<sp/>prepend<sp/>[prob,<sp/>tok_0,<sp/>tok_1,<sp/>...<sp/>tok_n]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>phrases<sp/>+=<sp/>[[prob]<sp/>+<sp/>tokenizer.std_token_phrases[i]</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>prob,<sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>zip(topk_probs_list[b],<sp/>topk_indices_list[b])]<sp/><sp/></highlight><highlight class="comment">#<sp/>[prob_k,<sp/>tok_0_k,<sp/>tok_1_k,<sp/>...]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="777"><highlight class="normal"></highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>also<sp/>add<sp/>prob_floor<sp/>for<sp/>batch<sp/>item</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>phrases<sp/>+=<sp/>[[floor_probs_list[b]]]<sp/><sp/></highlight><highlight class="comment">#<sp/>[prob_floor_b]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="780"><highlight class="normal"></highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>determine<sp/>width<sp/>of<sp/>topk_tensor<sp/>as<sp/>max<sp/>len<sp/>of<sp/>all<sp/>phrase<sp/>lists<sp/>(with<sp/>prob<sp/>in<sp/>front)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/>max_len<sp/>=<sp/>max([len(p)<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>p<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrases])<sp/><sp/></highlight><highlight class="comment">#<sp/>max_{b,k}(len([prob_k,<sp/>tok_0_k,<sp/>tok_1_k,<sp/>...]))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>form<sp/>single<sp/>2D<sp/>tensor<sp/>with<sp/>all<sp/>phrase<sp/>and<sp/>probs<sp/>(typically<sp/>to<sp/>send<sp/>to<sp/>axon<sp/>wire<sp/>encoding)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>=<sp/>torch.tensor([p<sp/>+<sp/>[ignore_index]<sp/>*<sp/>(max_len<sp/>-<sp/>len(p))</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>p<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrases]).to(logits.device)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="787"><highlight class="normal"></highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>grafting<sp/>probability<sp/>tensors<sp/>into<sp/>first<sp/>column<sp/>to<sp/>attach<sp/>gradients</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor[:,<sp/>0]<sp/>=<sp/>torch.hstack(probs)<sp/><sp/></highlight><highlight class="comment">#<sp/>tensor([prob_k=0_b,<sp/>prob_k=1_b,<sp/>...,<sp/>prob_floor_b])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"></highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>=<sp/>topk_tensor.reshape(batch_size,<sp/>topk<sp/>+<sp/>1,<sp/>max_len)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>reshaped</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="792"><highlight class="normal"></highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>topk_tensor<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>(probability<sp/>gradients<sp/>attached<sp/>in<sp/>first<sp/>column)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="794"><highlight class="normal"></highlight></codeline>
<codeline lineno="795"><highlight class="normal"></highlight></codeline>
<codeline lineno="796"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">compact_topk_token_phrases(topk_tensor:<sp/>torch.Tensor):</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="798"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Compact<sp/>2D<sp/>topk_tensor<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>by<sp/>removing<sp/>ignore_index<sp/>padding,<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>also<sp/>offset</highlight></codeline>
<codeline lineno="799"><highlight class="normal"><sp/><sp/><sp/><sp/>tokens<sp/>by<sp/>2<sp/>to<sp/>preserve<sp/>[0,<sp/>1]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>probabilities<sp/>to<sp/>allow<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>proper<sp/>unraveling<sp/>demarcated<sp/>by</highlight></codeline>
<codeline lineno="800"><highlight class="normal"><sp/><sp/><sp/><sp/>probability<sp/>boundaries.</highlight></codeline>
<codeline lineno="801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>tensor<sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob</highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>tok_1_k=1_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=0,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>tok_1_k=1_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=1,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...]]</highlight></codeline>
<codeline lineno="815"><highlight class="normal"></highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>compact_topk<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sum_b(sum_k(len(phrase_k)<sp/>+<sp/>1)_b)]<sp/>Compacted<sp/>1-D<sp/>tensor<sp/>&gt;=<sp/>batch_size<sp/>*<sp/>(2<sp/>*<sp/>topk<sp/>+<sp/>1),</highlight></codeline>
<codeline lineno="819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>since<sp/>2<sp/>*<sp/>topk<sp/>+<sp/>1:<sp/>topk<sp/>x<sp/>[probability,<sp/>token<sp/>sequence<sp/>(at<sp/>least<sp/>one<sp/>token)]<sp/>+</highlight></codeline>
<codeline lineno="820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>floor<sp/>probability<sp/>(rest).</highlight></codeline>
<codeline lineno="821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>...,<sp/>prob_floor_b=0,</highlight></codeline>
<codeline lineno="823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>...,<sp/>prob_floor_b=1,</highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...]</highlight></codeline>
<codeline lineno="825"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="826"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>topk_tensor_offset<sp/>=<sp/>topk_tensor.clone()<sp/><sp/></highlight><highlight class="comment">#<sp/>assume<sp/>topk_tensor<sp/>may<sp/>be<sp/>reused<sp/>elsewhere<sp/>so<sp/>clone</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor_offset[:,<sp/>:,<sp/>1:]<sp/>+=<sp/>2<sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>2<sp/>to<sp/>token<sp/>ids<sp/>to<sp/>preserve<sp/>[0,<sp/>1]<sp/>for<sp/>probabilities<sp/>(in<sp/>first<sp/>column)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal"><sp/><sp/><sp/><sp/>flattened<sp/>=<sp/>topk_tensor_offset.flatten()<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)<sp/>*<sp/>max_len]<sp/>1D<sp/>tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/>compact_topk<sp/>=<sp/>flattened[flattened<sp/>&gt;<sp/>-1]<sp/><sp/></highlight><highlight class="comment">#<sp/>remove<sp/>ignore_index<sp/>&lt;<sp/>-1<sp/>padding<sp/>to<sp/>compact<sp/>content</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>compact_topk<sp/><sp/></highlight><highlight class="comment">#<sp/>[&gt;=<sp/>batch_size<sp/>*<sp/>(2<sp/>*<sp/>topk<sp/>+<sp/>1)]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight></codeline>
<codeline lineno="834"><highlight class="normal"></highlight></codeline>
<codeline lineno="835"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">unravel_topk_token_phrases(compact_topk:<sp/>torch.Tensor,<sp/>topk:<sp/>int,<sp/>ignore_index:<sp/>int<sp/>=<sp/>-100)<sp/>-&gt;<sp/>torch.Tensor:</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="837"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Unravel<sp/>topk<sp/>token<sp/>phrases<sp/>input_tensor<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>1-D<sp/>to<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>topk_tensor,<sp/>which</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>compact_topk<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[sum_b(sum_k(len(phrase_k)<sp/>+<sp/>1)_b)]<sp/>Compacted<sp/>1-D<sp/>tensor<sp/>&gt;=<sp/>batch_size<sp/>*<sp/>(2<sp/>*<sp/>topk<sp/>+<sp/>1),</highlight></codeline>
<codeline lineno="843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>since<sp/>2<sp/>*<sp/>topk<sp/>+<sp/>1:<sp/>topk<sp/>x<sp/>[probability,<sp/>token<sp/>sequence<sp/>(at<sp/>least<sp/>one<sp/>token)]<sp/>+</highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>floor<sp/>probability<sp/>(rest).</highlight></codeline>
<codeline lineno="845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>...,<sp/>prob_floor_b=0,</highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>...,<sp/>prob_floor_b=1,</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...]</highlight></codeline>
<codeline lineno="849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk<sp/>(:obj:`int`,<sp/>`required`):</highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Amount<sp/>of<sp/>top<sp/>phrases<sp/>to<sp/>expect<sp/>(to<sp/>check<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>mismatch)</highlight></codeline>
<codeline lineno="851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ignore_index<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Padding<sp/>value<sp/>to<sp/>use<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>unfilled<sp/>token<sp/>positions<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>a<sp/>shorter<sp/>token<sp/>phrase.</highlight></codeline>
<codeline lineno="853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>tensor<sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>tok_1_k=1_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=0,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>tok_1_k=1_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=1,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...]]</highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="868"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="869"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>atol<sp/>=<sp/>1e-6<sp/><sp/></highlight><highlight class="comment">#<sp/>absolute<sp/>tolerance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Find<sp/>probability<sp/>markers<sp/>(per<sp/>batch<sp/>item:<sp/>topk<sp/>phrase<sp/>probabilities<sp/>+<sp/>floor_prob)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/>prob_idx<sp/>=<sp/>torch.where((-atol<sp/>&lt;<sp/>compact_topk)<sp/>&amp;<sp/>(compact_topk<sp/>&lt;<sp/>1<sp/>+<sp/>atol))[0]<sp/><sp/></highlight><highlight class="comment">#<sp/>0<sp/>&lt;=<sp/>prob<sp/>&lt;=<sp/>1<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)],<sp/>expect<sp/>token_ids<sp/>&gt;=<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"></highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><sp/><sp/>batch_size<sp/>=<sp/>len(prob_idx)<sp/>//<sp/>(topk<sp/>+<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>(batch_size<sp/>*<sp/>(topk<sp/>+<sp/>floor))<sp/>/<sp/>(topk<sp/>+<sp/>floor)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">assert</highlight><highlight class="normal"><sp/>batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)<sp/>==<sp/>len(prob_idx),<sp/>f</highlight><highlight class="stringliteral">&apos;unravel_topk_token_phrases()<sp/>probability<sp/>marker<sp/>failure:<sp/>&apos;</highlight><highlight class="normal"><sp/>\</highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f</highlight><highlight class="stringliteral">&apos;{batch_size}<sp/>*<sp/>({topk}<sp/>+<sp/>1)<sp/>!=<sp/>{len(prob_idx)}&apos;</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">#<sp/>decoding<sp/>irregularity<sp/>otherwise</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="876"><highlight class="normal"></highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>torch.clamp(compact_topk[prob_idx],<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)]<sp/>ensure<sp/>probabilities<sp/>within<sp/>[0,<sp/>1]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/>probs_sum<sp/>=<sp/>probs.reshape(batch_size,<sp/>topk<sp/>+<sp/>1).sum(dim=1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">assert</highlight><highlight class="normal"><sp/>torch.all((-atol<sp/>&lt;<sp/>probs_sum)<sp/>&amp;<sp/>(probs_sum<sp/>&lt;<sp/>1<sp/>+<sp/>atol)),<sp/>f</highlight><highlight class="stringliteral">&apos;unravel_topk_token_phrases():<sp/>probs_sum<sp/>not<sp/>in<sp/>[0,<sp/>1]&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="880"><highlight class="normal"></highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Obtain<sp/>phrase<sp/>lengths<sp/>and<sp/>maximum<sp/>phrase<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/>phrase_len<sp/>=<sp/>prob_idx[1:]<sp/>-<sp/>prob_idx[:-1]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)<sp/>-<sp/>1]<sp/>length<sp/>of<sp/>each<sp/>phrase</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/>phrase_len<sp/>=<sp/>torch.cat((phrase_len,<sp/>torch.tensor([1])))<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1)]<sp/>prob_floor<sp/>is<sp/>always<sp/>len=1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/>max_len<sp/>=<sp/>phrase_len.max()<sp/><sp/></highlight><highlight class="comment">#<sp/>determine<sp/>width<sp/>of<sp/>topk_tensor<sp/>as<sp/>max<sp/>len<sp/>of<sp/>all<sp/>phrase<sp/>lists<sp/>(with<sp/>prob<sp/>in<sp/>front)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="885"><highlight class="normal"></highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Initialize<sp/>topk_tensor<sp/>with<sp/>ignore_index<sp/>+<sp/>2,<sp/>since<sp/>decrement<sp/>with<sp/>2<sp/>follows<sp/>to<sp/>remove<sp/>token<sp/>offset<sp/>later</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="887"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>=<sp/>torch.ones((batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1),<sp/>max_len),<sp/>device=compact_topk.device)</highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>*=<sp/>ignore_index<sp/>+<sp/>2<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size<sp/>*<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="889"><highlight class="normal"></highlight></codeline>
<codeline lineno="890"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Insert<sp/>phrases<sp/>of<sp/>each<sp/>unique<sp/>length<sp/>as<sp/>block<sp/>into<sp/>topk_tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="891"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>unique_len<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>phrase_len.unique():</highlight></codeline>
<codeline lineno="892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>unique_len<sp/>&lt;=<sp/>1:</highlight></codeline>
<codeline lineno="893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">#<sp/>skip<sp/>probability<sp/>column,<sp/>will<sp/>be<sp/>added<sp/>afterward</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="894"><highlight class="normal"></highlight></codeline>
<codeline lineno="895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>phrase_idx<sp/>=<sp/>torch.where(phrase_len<sp/>==<sp/>unique_len)[0]<sp/><sp/></highlight><highlight class="comment">#<sp/>phrase<sp/>indices<sp/>where<sp/>phrase_len<sp/>is<sp/>unique_len</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>compact_idx<sp/>=<sp/>prob_idx[phrase_idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>indices<sp/>in<sp/>compact_topk</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="897"><highlight class="normal"></highlight></codeline>
<codeline lineno="898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Create<sp/>indexing<sp/>block,<sp/>add<sp/>index<sp/>for<sp/>each<sp/>phrase<sp/>position,<sp/>skip<sp/>first<sp/>(prob)<sp/>position</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block_idx<sp/>=<sp/>[compact_idx<sp/>+<sp/>position<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>position<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(1,<sp/>unique_len)]<sp/><sp/></highlight><highlight class="comment">#<sp/>incrementally<sp/>add<sp/>each<sp/>position<sp/>of<sp/>phrase</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>transpose<sp/>.t()<sp/>ensures<sp/>correct<sp/>interleaving<sp/>of<sp/>consecutive<sp/>positions:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>[[phrase_a_1,<sp/>phrase_a_2,<sp/>...,<sp/>phrase_a_n],<sp/>[phrase_b_1,<sp/>phrase_b_2,<sp/>...,<sp/>phrase_b_n],<sp/>...]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block_idx<sp/>=<sp/>torch.vstack(block_idx).t().reshape(-1,<sp/>unique_len<sp/>-<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[-1,<sp/>unique_len<sp/>-<sp/>1]<sp/>for<sp/>all<sp/>phrases<sp/>with<sp/>unique_len</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal"></highlight></codeline>
<codeline lineno="904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor[phrase_idx,<sp/>1:unique_len]<sp/>=<sp/>compact_topk[block_idx]<sp/><sp/></highlight><highlight class="comment">#<sp/>slice<sp/>selected<sp/>phrases<sp/>and<sp/>copy<sp/>into<sp/>topk_tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="905"><highlight class="normal"></highlight></codeline>
<codeline lineno="906"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>-=<sp/>2<sp/><sp/></highlight><highlight class="comment">#<sp/>remove<sp/>token<sp/>offset,<sp/>overwrites<sp/>probability<sp/>column,<sp/>replace<sp/>probabilities<sp/>below</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="907"><highlight class="normal"></highlight></codeline>
<codeline lineno="908"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>grafting<sp/>probability<sp/>tensors<sp/>into<sp/>first<sp/>column<sp/>to<sp/>attach<sp/>gradients</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="909"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor[:,<sp/>0]<sp/>=<sp/>probs<sp/><sp/></highlight><highlight class="comment">#<sp/>tensor([prob_k=0_b,<sp/>prob_k=1_b,<sp/>...,<sp/>prob_floor_b])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="910"><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tensor<sp/>=<sp/>topk_tensor.reshape(batch_size,<sp/>topk<sp/>+<sp/>1,<sp/>max_len)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>reshaped</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="912"><highlight class="normal"></highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>topk_tensor<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="914"><highlight class="normal"></highlight></codeline>
<codeline lineno="915"><highlight class="normal"></highlight></codeline>
<codeline lineno="916"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">phrase_cross_entropy(target_phrases:<sp/>Union[List[List[int]],<sp/>torch.Tensor],</highlight></codeline>
<codeline lineno="917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor:<sp/>torch.Tensor,</highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ignore_index:<sp/>int<sp/>=<sp/>-100,<sp/>reduce=</highlight><highlight class="keyword">True</highlight><highlight class="normal">,<sp/>reduction=</highlight><highlight class="stringliteral">&apos;mean&apos;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vocab_size_min:<sp/>int<sp/>=<sp/>50257)<sp/>-&gt;<sp/>Tuple[torch.Tensor,<sp/>torch.Tensor]:</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="921"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Calculates<sp/>the<sp/>cross<sp/>entropy<sp/>of<sp/>a<sp/>phrase<sp/>prediction<sp/>against<sp/>a<sp/>target<sp/>phrase,<sp/>so<sp/>that<sp/>this<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>a<sp/>multi-token</highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/>extension<sp/>of<sp/>typical<sp/>cross<sp/>entropy<sp/>calculated<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>next<sp/>token<sp/>prediction.</highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_phrases<sp/>(:obj:`List[List[int]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>*]<sp/>Target<sp/>phrases<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>standard<sp/>token<sp/>sequence<sp/>list.</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>tensor<sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob</highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>tok_1_k=1_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=0,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>tok_1_k=1_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=1,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...]]</highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ignore_index<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Padding<sp/>value<sp/>to<sp/>use<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>unfilled<sp/>token<sp/>positions<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>a<sp/>shorter<sp/>token<sp/>phrase.</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reduce<sp/>(:obj:`bool`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Whether<sp/>to<sp/>reduce<sp/>the<sp/>cross<sp/>entropy<sp/>over<sp/>the<sp/>batch<sp/>dimension.</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reduction<sp/>(:obj:`str`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Reduction<sp/>function<sp/>to<sp/>perform<sp/>when<sp/>reduce<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">True</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vocab_size_min<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Minimum<sp/>server<sp/>vocab_size<sp/>expected,<sp/>should<sp/>set<sp/>to<sp/>nominal<sp/>50257,</highlight></codeline>
<codeline lineno="947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>used<sp/>to<sp/>prevent<sp/>the<sp/>floor_probs<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>being<sp/>too<sp/>large.</highlight></codeline>
<codeline lineno="948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>loss_val<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Validation<sp/>cross<sp/>entropy<sp/>loss,<sp/>either<sp/>scalar<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>reduce<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>[batch_size].</highlight></codeline>
<codeline lineno="951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>loss<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Phrase<sp/>cross<sp/>entropy<sp/>loss,<sp/>either<sp/>scalar<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>reduce<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>[batch_size].</highlight></codeline>
<codeline lineno="953"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="954"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="955"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>batch_size,<sp/>topk_p1,<sp/>max_len<sp/>=<sp/>topk_tensor.shape<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="956"><highlight class="normal"><sp/><sp/><sp/><sp/>topk<sp/>=<sp/>topk_p1<sp/>-<sp/>1</highlight></codeline>
<codeline lineno="957"><highlight class="normal"></highlight></codeline>
<codeline lineno="958"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tokens<sp/>=<sp/>topk_tensor[:,<sp/>:-1,<sp/>1:].round().int()<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk,<sp/>max_len<sp/>-<sp/>1]<sp/>Phrase<sp/>tokens<sp/>with<sp/>ignore_index<sp/>token<sp/>for<sp/>padding.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="959"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs<sp/>=<sp/>topk_tensor[:,<sp/>:-1,<sp/>0]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>Probabilities<sp/>for<sp/>each<sp/>phrase<sp/>in<sp/>topk</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="960"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs<sp/>=<sp/>topk_tensor[:,<sp/>-1,<sp/>0]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>Floor<sp/>probabilities<sp/>as<sp/>mean<sp/>probability<sp/>for<sp/>non-topk<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="961"><highlight class="normal"></highlight></codeline>
<codeline lineno="962"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs<sp/>=<sp/>torch.clamp(topk_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>ensure<sp/>probabilities<sp/>within<sp/>[0,<sp/>1]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="963"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs<sp/>=<sp/>torch.clamp(floor_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>ensure<sp/>floor<sp/>probabilities<sp/>within<sp/>[0,<sp/>1]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="964"><highlight class="normal"></highlight></codeline>
<codeline lineno="965"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Ensure<sp/>total<sp/>probability<sp/>is<sp/>1<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/>total_probs<sp/>=<sp/>topk_probs.sum(dim=-1)<sp/>+<sp/>max(0,<sp/>vocab_size_min<sp/>-<sp/>topk)<sp/>*<sp/>floor_probs<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>total<sp/>probs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="967"><highlight class="normal"><sp/><sp/><sp/><sp/>n_topk_probs<sp/>=<sp/>topk_probs<sp/>/<sp/>total_probs[:,<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>normalized<sp/>topk_probs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/>n_floor_probs<sp/>=<sp/>floor_probs<sp/>/<sp/>total_probs<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>normalized<sp/>floor_probs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="969"><highlight class="normal"></highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/>val_probs<sp/>=<sp/>torch.zeros(batch_size).to(topk_probs.device)<sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>probabilities<sp/>when<sp/>first<sp/>tokens<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/>match_probs<sp/>=<sp/>torch.zeros(batch_size).to(topk_probs.device)<sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>probabilities<sp/>when<sp/>sub<sp/>target<sp/>matches<sp/>phrase</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>b<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(batch_size):</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_phrase<sp/>=<sp/>target_phrases[b]</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>isinstance(target_phrase,<sp/>torch.Tensor):</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_phrase<sp/>=<sp/>torch.tensor(target_phrases[b])</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>isinstance(target_phrase,<sp/>torch.FloatTensor):</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_phrase<sp/>=<sp/>target_phrase.round().int()</highlight></codeline>
<codeline lineno="978"><highlight class="normal"></highlight></codeline>
<codeline lineno="979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>match<sp/>=<sp/>(topk_tokens[b,<sp/>:,<sp/>0]<sp/>==<sp/>target_phrase[0].item())<sp/><sp/></highlight><highlight class="comment">#<sp/>bool<sp/>where<sp/>first<sp/>tokens<sp/>match<sp/>(validation<sp/>token)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>match.sum()<sp/>&gt;<sp/>0:</highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val_probs[b]<sp/>=<sp/>n_topk_probs[b,<sp/>match].sum()<sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>all<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>no<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val_probs[b]<sp/>=<sp/>n_floor_probs[b]<sp/><sp/></highlight><highlight class="comment">#<sp/>assume<sp/>match<sp/>is<sp/>in<sp/>non-topk<sp/>tokens<sp/>with<sp/>avg<sp/>floor_prob</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="984"><highlight class="normal"></highlight></codeline>
<codeline lineno="985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Integrate<sp/>sub<sp/>target<sp/>matches<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>check_len<sp/>=<sp/>min(max_len<sp/>-<sp/>1,<sp/>len(target_phrase))</highlight></codeline>
<codeline lineno="987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>c<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(1,<sp/>check_len<sp/>+<sp/>1):<sp/><sp/></highlight><highlight class="comment">#<sp/>progressively<sp/>increase<sp/>sub<sp/>target<sp/>length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>=<sp/>ignore_index<sp/>*<sp/>torch.ones(check_len,<sp/>dtype=torch.int32).to(topk_tensor.device)<sp/><sp/></highlight><highlight class="comment">#<sp/>[-100,<sp/>...,<sp/>-100]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target[:c]<sp/>=<sp/>target_phrase[:c]<sp/><sp/></highlight><highlight class="comment">#<sp/>[tok0,<sp/>tok1,<sp/>...tokc,<sp/>-100,<sp/>...,<sp/>-100]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="990"><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Find<sp/>sub<sp/>target<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>match<sp/>=<sp/>(topk_tokens[b,<sp/>:,<sp/>:check_len]<sp/>==<sp/>target)</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>match_idx<sp/>=<sp/>torch.where(match.sum(dim=-1)<sp/>==<sp/>check_len)[0]<sp/><sp/></highlight><highlight class="comment">#<sp/>phrase<sp/>indices<sp/>which<sp/>match<sp/>sub<sp/>target</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="994"><highlight class="normal"></highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>len(match_idx):<sp/><sp/></highlight><highlight class="comment">#<sp/>at<sp/>least<sp/>one<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>match_probs[b]<sp/>+=<sp/>n_topk_probs[b,<sp/>match_idx].sum()<sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>all<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>no<sp/>matches</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>match_probs[b]<sp/>+=<sp/>n_floor_probs[b]<sp/><sp/></highlight><highlight class="comment">#<sp/>assume<sp/>match<sp/>is<sp/>in<sp/>non-topk<sp/>tokens<sp/>with<sp/>avg<sp/>floor_prob</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="999"><highlight class="normal"></highlight></codeline>
<codeline lineno="1000"><highlight class="normal"><sp/><sp/><sp/><sp/>val_probs<sp/>=<sp/>torch.clamp(val_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>ensure<sp/>0<sp/>&lt;=<sp/>total<sp/>probability<sp/>&lt;=<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/>loss_val<sp/>=<sp/>-<sp/>torch.log(val_probs<sp/>+<sp/>1e-40)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>calculate<sp/>cross<sp/>entropy<sp/>loss</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1002"><highlight class="normal"></highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/>match_probs<sp/>=<sp/>torch.clamp(match_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>ensure<sp/>0<sp/>&lt;=<sp/>total<sp/>probability<sp/>&lt;=<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/>loss<sp/>=<sp/>-<sp/>torch.log(match_probs<sp/>+<sp/>1e-40)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>calculate<sp/>cross<sp/>entropy<sp/>loss</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1005"><highlight class="normal"></highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>reduce:</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(loss_val,<sp/>reduction)<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(loss,<sp/>reduction):</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">raise</highlight><highlight class="normal"><sp/>RuntimeError(f</highlight><highlight class="stringliteral">&apos;phase_cross_entropy():<sp/>Reduction<sp/>function<sp/>{reduction}<sp/>not<sp/>found.&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>loss_val<sp/>=<sp/>getattr(loss_val,<sp/>reduction)()</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>loss<sp/>=<sp/>getattr(loss,<sp/>reduction)()</highlight></codeline>
<codeline lineno="1011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>loss.numel()<sp/>&gt;<sp/>1:</highlight></codeline>
<codeline lineno="1012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">raise</highlight><highlight class="normal"><sp/>ValueError(f</highlight><highlight class="stringliteral">&apos;phase_cross_entropy():<sp/>Expected<sp/>reduction<sp/>to<sp/>scalar,<sp/>obtained<sp/>{loss.shape}<sp/>instead.&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1013"><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>loss_val,<sp/>loss</highlight></codeline>
<codeline lineno="1015"><highlight class="normal"></highlight></codeline>
<codeline lineno="1016"><highlight class="normal"></highlight></codeline>
<codeline lineno="1017"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">topk_tokens_to_vocab_size(topk_tensor:<sp/>torch.Tensor,<sp/>vocab_size_std:<sp/>int,<sp/>vocab_size_min:<sp/>int<sp/>=<sp/>50257)<sp/>-&gt;<sp/>torch.Tensor:</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1019"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Convert<sp/>topk_tokens<sp/>first<sp/>token<sp/>probabilities<sp/>into<sp/>a<sp/>standard<sp/>logits<sp/>tensor<sp/>shape<sp/>[batch_size,<sp/>vocab_size_std].</highlight></codeline>
<codeline lineno="1020"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1021"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>topk_tensor<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1022"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]<sp/>tensor<sp/>includes<sp/>topk<sp/>token<sp/>probabilities<sp/>(prob_k)<sp/>+<sp/>floor_prob</highlight></codeline>
<codeline lineno="1023"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>first<sp/>column<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gradients<sp/>attached,<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokens<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>remaining<sp/>columns<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>ignore_index<sp/>padding.</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Content<sp/>structure:</highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[[prob_k=0_b=0,<sp/>tok_0_k=0_b=0,<sp/>tok_1_k=0_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=0,<sp/>tok_0_k=1_b=0,<sp/>tok_1_k=1_b=0,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=0,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[prob_k=0_b=1,<sp/>tok_0_k=0_b=1,<sp/>tok_1_k=0_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_k=1_b=1,<sp/>tok_0_k=1_b=1,<sp/>tok_1_k=1_b=1,<sp/>...,<sp/>ignore_index?],</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...],</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[prob_floor_b=1,<sp/>ignore_index,<sp/>...,<sp/>ignore_index]],</highlight></codeline>
<codeline lineno="1033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[...]]</highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vocab_size_std<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>tokenizer<sp/>vocab_size<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>forming<sp/>logits.</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vocab_size_min<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Minimum<sp/>server<sp/>vocab_size<sp/>expected,<sp/>should<sp/>set<sp/>to<sp/>nominal<sp/>50257,</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>used<sp/>to<sp/>prevent<sp/>the<sp/>floor_probs<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>being<sp/>too<sp/>large.</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>logits<sp/>(:obj:`torch.Tensor`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[batch_size,<sp/>vocab_size_std]<sp/>Standard<sp/>logits.</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1043"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="1044"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>batch_size,<sp/>topk_p1,<sp/>max_len<sp/>=<sp/>topk_tensor.shape<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>(topk<sp/>+<sp/>1),<sp/>max_len]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1045"><highlight class="normal"><sp/><sp/><sp/><sp/>topk<sp/>=<sp/>topk_p1<sp/>-<sp/>1</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"></highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_tokens<sp/>=<sp/>topk_tensor[:,<sp/>:-1,<sp/>1].round().to(torch.int64)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>first<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1048"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs<sp/>=<sp/>topk_tensor[:,<sp/>:-1,<sp/>0]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>Probabilities<sp/>for<sp/>each<sp/>phrase<sp/>in<sp/>topk</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs<sp/>=<sp/>topk_tensor[:,<sp/>-1,<sp/>0]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>Floor<sp/>probabilities<sp/>as<sp/>mean<sp/>probability<sp/>for<sp/>non-topk<sp/>tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1050"><highlight class="normal"></highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/>topk_probs<sp/>=<sp/>torch.clamp(topk_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>ensure<sp/>probabilities<sp/>within<sp/>[0,<sp/>1]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/>floor_probs<sp/>=<sp/>torch.clamp(floor_probs,<sp/>0,<sp/>1)<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>ensure<sp/>floor<sp/>probabilities<sp/>within<sp/>[0,<sp/>1]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1053"><highlight class="normal"></highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Ensure<sp/>total<sp/>probability<sp/>is<sp/>1<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/>total_probs<sp/>=<sp/>topk_probs.sum(dim=-1)<sp/>+<sp/>max(0,<sp/>vocab_size_min<sp/>-<sp/>topk)<sp/>*<sp/>floor_probs<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size]<sp/>total<sp/>probs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/>n_topk_probs<sp/>=<sp/>topk_probs<sp/>/<sp/>total_probs[:,<sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>topk]<sp/>normalized<sp/>topk_probs</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1057"><highlight class="normal"></highlight></codeline>
<codeline lineno="1058"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Convert<sp/>to<sp/>logits<sp/>tensor<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1059"><highlight class="normal"><sp/><sp/><sp/><sp/>probs<sp/>=<sp/>torch.zeros((batch_size,<sp/>vocab_size_std))<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>vocab_size_std]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/><sp/><sp/>probs.scatter_add_(1,<sp/>topk_tokens,<sp/>n_topk_probs)<sp/><sp/></highlight><highlight class="comment">#<sp/>accumulate<sp/>token<sp/>probabilities<sp/>onto<sp/>logits<sp/>tensor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1061"><highlight class="normal"></highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>probs<sp/><sp/></highlight><highlight class="comment">#<sp/>[batch_size,<sp/>vocab_size_std]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1063"><highlight class="normal"></highlight></codeline>
<codeline lineno="1064"><highlight class="normal"></highlight></codeline>
<codeline lineno="1065"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a54a25644b9cfa6b662c66e0707692a72" kindref="member">check_tokenizer_equivalence</ref>(tokenizer_to_check:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="1066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_tokenizer:<sp/>PreTrainedTokenizerBase)<sp/>-&gt;<sp/>bool:</highlight></codeline>
<codeline lineno="1067"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1068"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Is<sp/>tokenizer_to_check<sp/>equivalent<sp/>to<sp/>target_tokenizer?</highlight></codeline>
<codeline lineno="1069"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1070"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer_to_check<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1071"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>to<sp/>check<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>equivalence.</highlight></codeline>
<codeline lineno="1072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Target<sp/>tokenizer<sp/>to<sp/>check<sp/>equivalence<sp/>against.</highlight></codeline>
<codeline lineno="1074"><highlight class="normal"></highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>(:obj:`bool`,<sp/>`required`)</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1078"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(tokenizer_to_check)</highlight></codeline>
<codeline lineno="1079"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(target_tokenizer)</highlight></codeline>
<codeline lineno="1080"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="1081"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer_to_check.vocab_len<sp/>!=<sp/>target_tokenizer.vocab_len:</highlight></codeline>
<codeline lineno="1082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1083"><highlight class="normal"></highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/><sp/><sp/>to_check_vocab<sp/>=<sp/>tokenizer_to_check.batch_decode(range(tokenizer_to_check.vocab_len))</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/><sp/><sp/>target_vocab<sp/>=<sp/>target_tokenizer.batch_decode(range(target_tokenizer.vocab_len))</highlight></codeline>
<codeline lineno="1086"><highlight class="normal"></highlight></codeline>
<codeline lineno="1087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>to_check_vocab<sp/>==<sp/>target_vocab<sp/><sp/></highlight><highlight class="comment">#<sp/>indexed<sp/>tokenizer<sp/>vocabularies<sp/>should<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1088"><highlight class="normal"></highlight></codeline>
<codeline lineno="1089"><highlight class="normal"></highlight></codeline>
<codeline lineno="1090"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">prune_tokens(inputs:<sp/>torch.FloatTensor,<sp/>prune_len:<sp/>int<sp/>=<sp/>1,<sp/>margin:<sp/>int<sp/>=<sp/>3):</highlight></codeline>
<codeline lineno="1091"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1092"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Prune<sp/>tokens<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>a<sp/>batch<sp/>of<sp/>sequences<sp/>randomly<sp/>by<sp/>removing<sp/>prune_len<sp/>tokens<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>each<sp/>sequence,</highlight></codeline>
<codeline lineno="1093"><highlight class="normal"><sp/><sp/><sp/><sp/>leaving<sp/>the<sp/>end<sp/>margin<sp/>intact.</highlight></codeline>
<codeline lineno="1094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inputs<sp/>(:obj:`torch.FloatTensor`<sp/>of<sp/>shape<sp/>:obj:`(batch_size,<sp/>seq_len)`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor<sp/>inputs<sp/>to<sp/>have<sp/>tokens<sp/>pruned.</highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prune_len<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number<sp/>of<sp/>tokens<sp/>to<sp/>prune<sp/></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>each<sp/>validation<sp/>input<sp/>sequence.</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>margin<sp/>(:obj:`int`,<sp/>`optional`):</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Number<sp/>of<sp/>tokens<sp/>at<sp/>the<sp/>end<sp/>of<sp/>the<sp/>sequence<sp/>to<sp/>leave<sp/>unpruned.</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pruned_inputs<sp/>(:obj:`torch.FloatTensor`<sp/>of<sp/>shape<sp/>:obj:`(batch_size,<sp/>seq_len<sp/>-<sp/>prune_len)`,<sp/>`required`)</highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1104"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>seq_len<sp/>=<sp/>len(inputs[0])</highlight></codeline>
<codeline lineno="1105"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>prune_len<sp/>&lt;=<sp/>0:</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>inputs</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>seq_len<sp/>-<sp/>margin<sp/>&lt;<sp/>prune_len:</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prune_len<sp/>=<sp/>seq_len<sp/>-<sp/>margin</highlight></codeline>
<codeline lineno="1109"><highlight class="normal"><sp/><sp/><sp/><sp/>pruned_inputs<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>b<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(len(inputs)):</highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rand_index<sp/>=<sp/>torch.randperm(seq_len<sp/>-<sp/>margin)[:prune_len]</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mask<sp/>=<sp/>torch.ones(seq_len,<sp/>dtype=torch.bool)</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mask[rand_index]<sp/>=<sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pruned_inputs.append(inputs[b,<sp/>mask])</highlight></codeline>
<codeline lineno="1115"><highlight class="normal"></highlight></codeline>
<codeline lineno="1116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>torch.stack(pruned_inputs)</highlight></codeline>
<codeline lineno="1117"><highlight class="normal"></highlight></codeline>
<codeline lineno="1118"><highlight class="normal"></highlight></codeline>
<codeline lineno="1119"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">pad_offsets(offsets_batch:<sp/>List[List[tuple]],<sp/>source_offsets_batch:<sp/>List[List[List[Any]]],</highlight></codeline>
<codeline lineno="1120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_offsets_batch:<sp/>List[List[List[Any]]])<sp/>-&gt;<sp/>List[List[List[Any]]]:</highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1122"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Pads<sp/>specific<sp/>tuples<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets_batch,<sp/>selected<sp/>by<sp/>source_offsets_batch<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/>associated<sp/>paddings<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>pad_offsets_batch.</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"><sp/><sp/><sp/><sp/>Purpose<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>typically<sp/>to<sp/>add<sp/>padding<sp/>to<sp/>align<sp/>two<sp/>tokenization<sp/>offsets<sp/>at<sp/>special<sp/>tokens.</highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offsets_batch<sp/>(:obj:`List[List[tuple]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>full<sp/>input<sp/>tokenizer<sp/>offset<sp/>mappings<sp/>to<sp/>be<sp/>used<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>alteration</highlight></codeline>
<codeline lineno="1128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>source_offsets_batch<sp/>(:obj:`List[List[List[Any]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>tokenizer<sp/>offset<sp/>mappings<sp/>indicating<sp/>replacement<sp/>tuples<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets_batch</highlight></codeline>
<codeline lineno="1131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_offsets_batch<sp/>(:obj:`List[List[List[Any]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>offset<sp/>paddings<sp/>associated<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>each<sp/>source_offsets_batch<sp/>replacement<sp/>tuple</highlight></codeline>
<codeline lineno="1134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_pad_0,<sp/>right_pad_0),<sp/>(left_pad_1,<sp/>right_pad_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1135"><highlight class="normal"></highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets_batch<sp/>(:obj:`List[List[List[Any]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>padded<sp/>full<sp/>input<sp/>tokenizer<sp/>offset<sp/>mappings</highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1141"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>new_offsets_batch<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1142"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>batch_len<sp/>=<sp/>len(offsets_batch)</highlight></codeline>
<codeline lineno="1143"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="1144"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>b<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(batch_len):</highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"></highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="1149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>left,<sp/>right<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets_batch[b]:<sp/><sp/></highlight><highlight class="comment">#<sp/>go<sp/>through<sp/>original<sp/>offsets</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>idx<sp/>&lt;<sp/>len(source_offsets_batch[b]):</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>source_left,<sp/>source_right<sp/>=<sp/>source_offsets_batch[b][idx]</highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>left<sp/>==<sp/>source_left<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>right<sp/>==<sp/>source_right:<sp/><sp/></highlight><highlight class="comment">#<sp/>matching<sp/>offset<sp/>found</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_left,<sp/>pad_right<sp/>=<sp/>pad_offsets_batch[b][idx]</highlight></codeline>
<codeline lineno="1154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets<sp/>+=<sp/>[(pad_left<sp/>+<sp/>pad,<sp/>pad_right<sp/>+<sp/>pad)]<sp/><sp/></highlight><highlight class="comment">#<sp/>replace<sp/>offsets<sp/>with<sp/>padded<sp/>+<sp/>accum.<sp/>pad</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad<sp/>+=<sp/>pad_right<sp/>-<sp/>right</highlight></codeline>
<codeline lineno="1156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets<sp/>+=<sp/>[(left<sp/>+<sp/>pad,<sp/>right<sp/>+<sp/>pad)]<sp/><sp/></highlight><highlight class="comment">#<sp/>adjust<sp/>original<sp/>offsets<sp/>w/<sp/>accum.<sp/>pad</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1159"><highlight class="normal"></highlight></codeline>
<codeline lineno="1160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets_batch<sp/>+=<sp/>[new_offsets]</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"></highlight></codeline>
<codeline lineno="1162"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_offsets_batch</highlight></codeline>
<codeline lineno="1163"><highlight class="normal"></highlight></codeline>
<codeline lineno="1164"><highlight class="normal"></highlight></codeline>
<codeline lineno="1165"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a58bc4ccb79ae645c72c7a5e4244b99d3" kindref="member">find_offsets</ref>(string:<sp/>str,<sp/>substring:<sp/>str)<sp/>-&gt;<sp/>List[List[int]]:</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1167"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Finds<sp/>all<sp/>the<sp/>[start,<sp/>end]<sp/>offsets<sp/>of<sp/>substring<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>string.</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"><sp/><sp/><sp/><sp/>Assumes<sp/>there<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>no<sp/>overlap<sp/>of<sp/>substring,<sp/>nor<sp/>recursive<sp/>overlap.</highlight></codeline>
<codeline lineno="1169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>(:obj:`str`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Main<sp/>string<sp/>to<sp/>find<sp/>offsets<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>substring<sp/>(:obj:`str`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Substring<sp/>to<sp/>search<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>string.</highlight></codeline>
<codeline lineno="1174"><highlight class="normal"></highlight></codeline>
<codeline lineno="1175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offsets<sp/>(:obj:`List[List[int]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Offsets<sp/>denoting<sp/>the<sp/>[start,<sp/>end]<sp/>positions<sp/>of<sp/>substring<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>string.</highlight></codeline>
<codeline lineno="1178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1179"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>offsets<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1180"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>idx<sp/>=<sp/>string.find(substring)<sp/><sp/></highlight><highlight class="comment">#<sp/>find<sp/>first<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1181"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>idx<sp/>!=<sp/>-1:<sp/><sp/></highlight><highlight class="comment">#<sp/>found<sp/>an<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offsets<sp/>+=<sp/>[[idx,<sp/>idx<sp/>+<sp/>len(substring)]]<sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>offsets</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx<sp/>=<sp/>string.find(substring,<sp/>idx<sp/>+<sp/>len(substring))<sp/><sp/></highlight><highlight class="comment">#<sp/>find<sp/>next<sp/>instance</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1184"><highlight class="normal"></highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>offsets</highlight></codeline>
<codeline lineno="1186"><highlight class="normal"></highlight></codeline>
<codeline lineno="1187"><highlight class="normal"></highlight></codeline>
<codeline lineno="1188"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8e57c9718294c345d7f4ff730970723d" kindref="member">replace_at_offsets</ref>(string:<sp/>str,<sp/>offsets:<sp/>List[List[Any]])<sp/>-&gt;<sp/>Tuple[str,<sp/>List[List[int]]]:</highlight></codeline>
<codeline lineno="1189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1190"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Replace<sp/>indicated<sp/>[left,<sp/>right]<sp/>offset<sp/>positions<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>a<sp/>new<sp/>substring,<sp/>by</highlight></codeline>
<codeline lineno="1191"><highlight class="normal"><sp/><sp/><sp/><sp/>deleting<sp/>[left,<sp/>right]<sp/>content<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>adding<sp/>[left,<sp/>left+len(substring)]<sp/>substring,</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"><sp/><sp/><sp/><sp/>adjusting<sp/>offsets<sp/>incrementally.</highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/><sp/><sp/>Assumes<sp/>an<sp/>incremental<sp/>ordered,<sp/>non-overlapping<sp/>list<sp/>of<sp/>offsets,<sp/>constructing</highlight></codeline>
<codeline lineno="1194"><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>new<sp/>string<sp/>incrementally<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>recording<sp/>new<sp/>offsets.</highlight></codeline>
<codeline lineno="1195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>(:obj:`str`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Main<sp/>string<sp/>to<sp/>perform<sp/>replacements<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offsets<sp/>(:obj:`List[List[Any]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Offsets<sp/>where<sp/>replacements<sp/>are<sp/>made<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>replacement<sp/>substring</highlight></codeline>
<codeline lineno="1200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[left_0,<sp/>right_0,<sp/>substring_0],<sp/>...]</highlight></codeline>
<codeline lineno="1201"><highlight class="normal"></highlight></codeline>
<codeline lineno="1202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_string<sp/>(:obj:`str`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>New<sp/>string<sp/>where<sp/>replacements<sp/>were<sp/>made.</highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets<sp/>(:obj:`List[List[Any]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>New<sp/>offsets<sp/>where<sp/>replacements<sp/>are<sp/>now<sp/>located</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[left_0,<sp/>right_0],<sp/>[left_1,<sp/>right_1],<sp/>...]</highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1209"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>new_string<sp/>=<sp/>&apos;&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1210"><highlight class="normal"><sp/><sp/><sp/><sp/>new_offsets<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1211"><highlight class="normal"></highlight></codeline>
<codeline lineno="1212"><highlight class="normal"><sp/><sp/><sp/><sp/>prev<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="1213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>left,<sp/>right,<sp/>substring<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets:</highlight></codeline>
<codeline lineno="1214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_string<sp/>+=<sp/>string[prev:left]<sp/><sp/></highlight><highlight class="comment">#<sp/>retain<sp/>preceding<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_left<sp/>=<sp/>len(new_string)<sp/><sp/></highlight><highlight class="comment">#<sp/>advance<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1216"><highlight class="normal"></highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_string<sp/>+=<sp/>substring<sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>new<sp/>substring</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_right<sp/>=<sp/>len(new_string)</highlight></codeline>
<codeline lineno="1219"><highlight class="normal"></highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_offsets<sp/>+=<sp/>[[new_left,<sp/>new_right]]<sp/><sp/></highlight><highlight class="comment">#<sp/>add<sp/>offsets</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1221"><highlight class="normal"></highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prev<sp/>=<sp/>right<sp/><sp/></highlight><highlight class="comment">#<sp/>advance<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1223"><highlight class="normal"></highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/>new_string<sp/>+=<sp/>string[prev:]</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"></highlight></codeline>
<codeline lineno="1226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_string,<sp/>new_offsets</highlight></codeline>
<codeline lineno="1227"><highlight class="normal"></highlight></codeline>
<codeline lineno="1228"><highlight class="normal"></highlight></codeline>
<codeline lineno="1229"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a4da460aad949bf91a0f414c1a0f30df1" kindref="member">get_special_token_pairings</ref>(from_tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="1230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer:<sp/>PreTrainedTokenizerBase)<sp/>-&gt;<sp/>Dict[str,<sp/>str]:</highlight></codeline>
<codeline lineno="1231"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1232"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Determines<sp/>a<sp/>prioritized<sp/>matching<sp/>of<sp/>special<sp/>token<sp/>texts<sp/>between<sp/>two<sp/>tokenizers.</highlight></codeline>
<codeline lineno="1233"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Purpose<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>to<sp/>produce<sp/>replacement<sp/>pairs<sp/>so<sp/>special<sp/>token<sp/>test<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/>correctly<sp/>represented<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>target<sp/>tokenizer.</highlight></codeline>
<codeline lineno="1234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>From<sp/>tokenizer.</highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>To<sp/>tokenizer.</highlight></codeline>
<codeline lineno="1239"><highlight class="normal"></highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pairings<sp/>(:obj:`Dict[str,<sp/>str]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Prioritized<sp/>dictionary<sp/>of<sp/>From_special_token_text<sp/>-&gt;<sp/>To_special_token_text.</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1244"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>pairings<sp/>=<sp/>{}</highlight></codeline>
<codeline lineno="1245"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="1246"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>some<sp/>tokenizers<sp/>e.g.<sp/>GPT2<sp/>have<sp/>the<sp/>same<sp/>text<sp/>signifying<sp/>BOS<sp/>and<sp/>EOS,<sp/>while<sp/>in<sp/>other<sp/>e.g.<sp/>XGLM<sp/>they<sp/>differ</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>so<sp/>prioritize<sp/>EOS<sp/>token<sp/>first,<sp/>since<sp/>this<sp/>seems<sp/>to<sp/>be<sp/>the<sp/>default<sp/>context<sp/>separator,<sp/>e.g.<sp/>XGLM,<sp/>GerPT2,<sp/>GPT2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="stringliteral">&apos;eos_token&apos;</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_tokenizer.special_tokens_map)<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>(</highlight><highlight class="stringliteral">&apos;eos_token&apos;</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>to_tokenizer.special_tokens_map):</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pairings[getattr(from_tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;eos_token&apos;</highlight><highlight class="normal">)]<sp/>=<sp/>getattr(to_tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;eos_token&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1250"><highlight class="normal"></highlight></codeline>
<codeline lineno="1251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>special_token<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_tokenizer.special_tokens_map:</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>special_token<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>to_tokenizer.special_tokens_map:</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>getattr(from_tokenizer,<sp/>special_token)<sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>pairings:<sp/><sp/></highlight><highlight class="comment">#<sp/>prevent<sp/>priority<sp/>overwrite</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pairings[getattr(from_tokenizer,<sp/>special_token)]<sp/>=<sp/>getattr(to_tokenizer,<sp/>special_token)</highlight></codeline>
<codeline lineno="1255"><highlight class="normal"></highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pairings</highlight></codeline>
<codeline lineno="1257"><highlight class="normal"></highlight></codeline>
<codeline lineno="1258"><highlight class="normal"></highlight></codeline>
<codeline lineno="1259"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">translate_special_token_text(text_batch:<sp/>List[str],<sp/>from_tokenizer:<sp/>PreTrainedTokenizerBase,</highlight></codeline>
<codeline lineno="1260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer:<sp/>PreTrainedTokenizerBase)<sp/>-&gt;<sp/>Tuple[List[str],</highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List[List[List[int]]],</highlight></codeline>
<codeline lineno="1262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List[List[List[int]]],</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List[List[List[Any]]]]:</highlight></codeline>
<codeline lineno="1264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1265"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Translates<sp/>special_token<sp/>signifier<sp/>text<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_tokenizer<sp/>to<sp/>to_tokenizer<sp/>special_token<sp/>text,<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1266"><highlight class="normal"><sp/><sp/><sp/><sp/>a<sp/>given<sp/>text_batch.<sp/>Resulting<sp/>to_text_batch<sp/>can<sp/>then<sp/>be<sp/>to_tokenized<sp/>where<sp/>special_tokens<sp/>should</highlight></codeline>
<codeline lineno="1267"><highlight class="normal"><sp/><sp/><sp/><sp/>map<sp/>to<sp/>its<sp/>single<sp/>corresponding<sp/>token,<sp/>despite<sp/>signifier<sp/>text<sp/>difference<sp/>compared<sp/>to<sp/>from_tokenizer.</highlight></codeline>
<codeline lineno="1268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>text_batch<sp/>(:obj:`List[str]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List<sp/>of<sp/>strings<sp/>to<sp/>translate<sp/>special<sp/>tokens<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>From<sp/>tokenizer.</highlight></codeline>
<codeline lineno="1273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>To<sp/>tokenizer.</highlight></codeline>
<codeline lineno="1275"><highlight class="normal"></highlight></codeline>
<codeline lineno="1276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_text_batch<sp/>(:obj:`List[str]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List<sp/>of<sp/>strings<sp/>where<sp/>special<sp/>text<sp/>has<sp/>been<sp/>replaced.</highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_offsets_batch<sp/>(:obj:`List[List[List[int]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>tokenizer<sp/>offset<sp/>mappings<sp/>selecting<sp/>replacement<sp/>tuples<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_tokenizer<sp/>text</highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_offsets_batch<sp/>(:obj:`List[List[List[int]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>tokenizer<sp/>offset<sp/>mappings<sp/>selecting<sp/>replacement<sp/>tuples<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>to_tokenizer<sp/>text</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_0,<sp/>right_0),<sp/>(left_1,<sp/>right_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_offsets_batch<sp/>(:obj:`List[List[List[Any]]]`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Batch<sp/>of<sp/>offset<sp/>paddings<sp/>associated<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>each<sp/>replacement<sp/>tuple</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[[(left_pad_0,<sp/>right_pad_0),<sp/>(left_pad_1,<sp/>right_pad_1),<sp/>...],<sp/>...].</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1289"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>to_text_batch<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1290"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>from_offsets_batch<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1291"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>to_offsets_batch<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1292"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>pad_offsets_batch<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1293"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="1294"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Get<sp/>special-token<sp/>text<sp/>replacement<sp/>pairs<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1295"><highlight class="normal"><sp/><sp/><sp/><sp/>pairings<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a4da460aad949bf91a0f414c1a0f30df1" kindref="member">get_special_token_pairings</ref>(from_tokenizer,<sp/>to_tokenizer)</highlight></codeline>
<codeline lineno="1296"><highlight class="normal"></highlight></codeline>
<codeline lineno="1297"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>text<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>text_batch:</highlight></codeline>
<codeline lineno="1298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_offsets<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>padding_offsets<sp/>=<sp/>[]</highlight></codeline>
<codeline lineno="1300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>token_string<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>pairings:</highlight></codeline>
<codeline lineno="1301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offsets<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a58bc4ccb79ae645c72c7a5e4244b99d3" kindref="member">find_offsets</ref>(text,<sp/>token_string)<sp/><sp/></highlight><highlight class="comment">#<sp/>find<sp/>special-token<sp/>locations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_offsets<sp/>+=<sp/>[[left,<sp/>right,<sp/>pairings[token_string]]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>left,<sp/>right<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets]</highlight></codeline>
<codeline lineno="1303"><highlight class="normal"></highlight></codeline>
<codeline lineno="1304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_string<sp/>=<sp/>token_string<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>len(token_string)<sp/>&gt;<sp/>len(pairings[token_string])<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>pairings[token_string]</highlight></codeline>
<codeline lineno="1305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>padding_offsets<sp/>+=<sp/>[[left,<sp/>right,<sp/>pad_string]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>left,<sp/>right<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>offsets]</highlight></codeline>
<codeline lineno="1306"><highlight class="normal"></highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_offsets<sp/>=<sp/>sorted(from_offsets)<sp/><sp/></highlight><highlight class="comment">#<sp/>incrementally<sp/>arrange<sp/>locations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_text,<sp/>to_offsets<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8e57c9718294c345d7f4ff730970723d" kindref="member">replace_at_offsets</ref>(text,<sp/>from_offsets)<sp/><sp/></highlight><highlight class="comment">#<sp/>replace<sp/>special-token<sp/>text</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_text,<sp/>padding_offsets<sp/>=<sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a8e57c9718294c345d7f4ff730970723d" kindref="member">replace_at_offsets</ref>(text,<sp/>padding_offsets)<sp/><sp/></highlight><highlight class="comment">#<sp/>pad<sp/>special-token<sp/>text<sp/>locations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1310"><highlight class="normal"></highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_text_batch<sp/>+=<sp/>[to_text]</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from_offsets_batch<sp/>+=<sp/>[[[left,<sp/>right]<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>left,<sp/>right,<sp/>_<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>from_offsets]]</highlight></codeline>
<codeline lineno="1313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>to_offsets_batch<sp/>+=<sp/>[to_offsets]</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pad_offsets_batch<sp/>+=<sp/>[padding_offsets]</highlight></codeline>
<codeline lineno="1315"><highlight class="normal"></highlight></codeline>
<codeline lineno="1316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>to_text_batch,<sp/>from_offsets_batch,<sp/>to_offsets_batch,<sp/>pad_offsets_batch</highlight></codeline>
<codeline lineno="1317"><highlight class="normal"></highlight></codeline>
<codeline lineno="1318"><highlight class="normal"></highlight></codeline>
<codeline lineno="1319"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(tokenizer:<sp/>PreTrainedTokenizerBase):</highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1321"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Sets<sp/>the<sp/>tokenizer.vocab_len<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>unset,<sp/>to<sp/>store<sp/>the<sp/>real<sp/>vocabulary<sp/>size<sp/>according<sp/>to<sp/>the<sp/>vocab<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>encoder.</highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>to<sp/>set<sp/>vocab_len<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"></highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1328"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;vocab_len&apos;</highlight><highlight class="normal">):</highlight></codeline>
<codeline lineno="1329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;vocab&apos;</highlight><highlight class="normal">):<sp/><sp/></highlight><highlight class="comment">#<sp/>use<sp/>independent<sp/>vocab_len<sp/>when<sp/>tokenizer.vocab_size<sp/>!=<sp/>len(tokenizer.vocab)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.vocab_len<sp/>=<sp/>len(tokenizer.vocab)</highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;encoder&apos;</highlight><highlight class="normal">):<sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizers<sp/>like<sp/>facebook/opt-*<sp/>has<sp/>encoder=vocab</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.vocab_len<sp/>=<sp/>len(tokenizer.encoder)</highlight></codeline>
<codeline lineno="1333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:<sp/><sp/></highlight><highlight class="comment">#<sp/>revert<sp/>to<sp/>vocab_size</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.vocab_len<sp/>=<sp/>tokenizer.vocab_size</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"></highlight></codeline>
<codeline lineno="1336"><highlight class="normal"></highlight></codeline>
<codeline lineno="1337"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a558123e572c10af14c002993c9b04f36" kindref="member">set_whitespace_preserving</ref>(tokenizer:<sp/>PreTrainedTokenizerBase):</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1339"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Sets<sp/>the<sp/>tokenizer.whitespace_preserving<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>unset,<sp/>indicates<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer<sp/>preserves<sp/>whitespace<sp/>like<sp/>GPT-style,</highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>like<sp/>BERT-style.</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer<sp/>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>to<sp/>set<sp/>vocab_len<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"></highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1347"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;whitespace_preserving&apos;</highlight><highlight class="normal">):</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>space_token<sp/>=<sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(</highlight><highlight class="stringliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">,<sp/>add_special_tokens=</highlight><highlight class="keyword">False</highlight><highlight class="normal">)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">]</highlight></codeline>
<codeline lineno="1349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>space_text<sp/>=<sp/>tokenizer.decode(space_token)</highlight></codeline>
<codeline lineno="1350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>space_text<sp/>==<sp/></highlight><highlight class="stringliteral">&apos;<sp/>&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.whitespace_preserving<sp/>=<sp/></highlight><highlight class="keyword">True</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.whitespace_preserving<sp/>=<sp/></highlight><highlight class="keyword">False</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1354"><highlight class="normal"></highlight></codeline>
<codeline lineno="1355"><highlight class="normal"></highlight></codeline>
<codeline lineno="1356"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal"><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a066a0913f46f47503972e5df32808063" kindref="member">set_std_token_phrases</ref>(tokenizer,<sp/>std_tokenizer):</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">r&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1358"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Sets<sp/>std_token_phrases<sp/>which<sp/>are<sp/>the<sp/>tokenizer<sp/>token<sp/>strings<sp/>tokenized<sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>std_tokenizer,<sp/>so</highlight></codeline>
<codeline lineno="1359"><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>std_tokenizer<sp/>equivalent<sp/>of<sp/>the<sp/>tokenizer<sp/>token<sp/>strings.</highlight></codeline>
<codeline lineno="1360"><highlight class="normal"><sp/><sp/><sp/><sp/>Used<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>converting<sp/>model<sp/>predictions/logits<sp/>into<sp/>std_tokenizer<sp/>representations,<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>example<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>TextCausalLMNext.</highlight></codeline>
<codeline lineno="1361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args:</highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classbittensor_1_1__tokenizer_1_1tokenizer" kindref="compound">tokenizer</ref>(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tokenizer<sp/>to<sp/>set<sp/>std_token_phrases<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">.</highlight></codeline>
<codeline lineno="1364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std_tokenizer(:obj:`PreTrainedTokenizerBase`,<sp/>`required`):</highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Standard<sp/>bittensor<sp/>tokenizer<sp/>to<sp/>convert<sp/>to.</highlight></codeline>
<codeline lineno="1366"><highlight class="normal"></highlight></codeline>
<codeline lineno="1367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Returns:</highlight></codeline>
<codeline lineno="1368"><highlight class="normal"></highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="1370"><highlight class="stringliteral"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>===<sp/>Tokenizer<sp/>phrases<sp/>to<sp/>memory<sp/>===</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;phrases&apos;</highlight><highlight class="normal">):</highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer.whitespace_preserving:</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.phrases<sp/>=<sp/>tokenizer.batch_decode(range(tokenizer.vocab_len))<sp/><sp/></highlight><highlight class="comment">#<sp/>server<sp/>tokens<sp/>to<sp/>strings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.phrases<sp/>=<sp/>[</highlight><highlight class="stringliteral">&apos;<sp/>&apos;</highlight><highlight class="normal"><sp/>+<sp/>phrase<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>phrase<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.batch_decode(range(tokenizer.vocab_len))]<sp/><sp/></highlight><highlight class="comment">#<sp/>server<sp/>tokens<sp/>to<sp/>strings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1377"><highlight class="normal"></highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/>hasattr(tokenizer,<sp/></highlight><highlight class="stringliteral">&apos;std_token_phrases&apos;</highlight><highlight class="normal">):</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Retokenize<sp/>phrases<sp/>to<sp/>new<sp/>tokenizer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.std_token_phrases<sp/>=<sp/>std_tokenizer(tokenizer.phrases)[</highlight><highlight class="stringliteral">&apos;input_ids&apos;</highlight><highlight class="normal">]<sp/><sp/></highlight><highlight class="comment">#<sp/>[topk,<sp/>max_len]<sp/>convert<sp/>phrases<sp/>to<sp/>tokens<sp/>sequences</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1381"><highlight class="normal"></highlight></codeline>
<codeline lineno="1382"><highlight class="normal"></highlight></codeline>
<codeline lineno="1383"><highlight class="normal"></highlight><highlight class="keyword">def<sp/></highlight><highlight class="normal">prep_tokenizer(tokenizer,<sp/>std_tokenizer=None):</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"><sp/><sp/><sp/><sp/>tokenizer.padding_side<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;left&quot;</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">#<sp/>Generative<sp/>default<sp/>expects<sp/>most<sp/>recent<sp/>token<sp/>on<sp/>right-hand<sp/>side<sp/>with<sp/>padding<sp/>on<sp/>left.<sp/>https://github.com/huggingface/transformers/pull/10552</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_prefix_space<sp/>=<sp/>False</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1386"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;bos_token&apos;:<sp/>&quot;[BOS]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>representing<sp/>the<sp/>beginning<sp/>of<sp/>a<sp/>sentence.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1387"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;eos_token&apos;:<sp/>&quot;[EOS]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>representing<sp/>the<sp/>end<sp/>of<sp/>a<sp/>sentence.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;unk_token&apos;:<sp/>&quot;[UNK]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>representing<sp/>an<sp/>out-of-vocabulary<sp/>token.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1389"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;sep_token&apos;:<sp/>&quot;[SEP]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>separating<sp/>two<sp/>different<sp/>sentences<sp/>in<sp/>the<sp/>same<sp/>input<sp/>(used<sp/>by<sp/>BERT<sp/>for<sp/>instance)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1390"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;pad_token&apos;:<sp/>&quot;[PAD]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>used<sp/>to<sp/>make<sp/>arrays<sp/>of<sp/>tokens<sp/>the<sp/>same<sp/>size<sp/>for<sp/>batching<sp/>purpose.<sp/>Will<sp/>then<sp/>be<sp/>ignored<sp/>by<sp/>attention<sp/>mechanisms<sp/>or<sp/>loss<sp/>computation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1391"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;cls_token&apos;:<sp/>&quot;[CLS]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>representing<sp/>the<sp/>class<sp/>of<sp/>the<sp/>input<sp/>(used<sp/>by<sp/>BERT<sp/>for<sp/>instance).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.add_special_tokens({&apos;mask_token&apos;:<sp/>&quot;[MASK]&quot;})<sp/>#<sp/>A<sp/>special<sp/>token<sp/>representing<sp/>a<sp/>masked<sp/>token<sp/>(used<sp/>by<sp/>masked-language<sp/>modeling<sp/>pretraining<sp/>objectives,<sp/>like<sp/>BERT).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>additional_special_tokens<sp/>=<sp/>[</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;s&gt;NOTUSED&quot;,<sp/><sp/>#<sp/>Used<sp/>by<sp/>BARThez</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;/s&gt;NOTUSED&quot;,<sp/>#<sp/>Used<sp/>by<sp/>BARThez</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;eop&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>MarianMT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;eod&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>MarianMT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;formula&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>Transformer<sp/>XL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;mask_1&gt;&quot;<sp/>#<sp/>Used<sp/>by<sp/>Pegasus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1400"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special0&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special1&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special2&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special3&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special4&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special5&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special6&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special7&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1408"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special8&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/><sp/><sp/><sp/><sp/>&quot;&lt;special9&gt;&quot;,<sp/>#<sp/>Used<sp/>by<sp/>XLM</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>tokenizer.additional_special_tokens<sp/>=<sp/>additional_special_tokens</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1412"><highlight class="normal"></highlight></codeline>
<codeline lineno="1413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Define<sp/>PAD<sp/>Token<sp/>=<sp/>EOS<sp/>Token<sp/>(GPT2<sp/>generate<sp/>convention,<sp/>when<sp/>PAD<sp/>Token<sp/>is<sp/>None)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>https://github.com/huggingface/transformers/blob/49c8c67fb815a277405f84dea4a66353e19fb347/tests/models/gpt2/test_modeling_gpt2.py#L532</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>tokenizer.pad_token<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>tokenizer.eos_token<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokenizer.pad_token<sp/>=<sp/>tokenizer.eos_token</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1aef7aceb6bc8b3ad0d08f7fed25c876d8" kindref="member">set_vocab_len</ref>(tokenizer)</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a558123e572c10af14c002993c9b04f36" kindref="member">set_whitespace_preserving</ref>(tokenizer)</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"></highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>std_tokenizer<sp/></highlight><highlight class="keywordflow">is</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">not</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">None</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacebittensor_1_1utils_1_1tokenizer__utils_1a066a0913f46f47503972e5df32808063" kindref="member">set_std_token_phrases</ref>(tokenizer,<sp/>std_tokenizer)</highlight></codeline>
<codeline lineno="1422"><highlight class="normal"></highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>tokenizer</highlight></codeline>
    </programlisting>
    <location file="/Users/macthrasher/bittensor/bittensor/utils/tokenizer_utils.py"/>
  </compounddef>
</doxygen>
